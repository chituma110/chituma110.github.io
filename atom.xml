<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程起上的博客</title>
  
  <subtitle>Goals determine what you are going to be</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-03-15T05:27:30.218Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>chengqishang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python-Random</title>
    <link href="http://yoursite.com/2018/05/17/python-random/"/>
    <id>http://yoursite.com/2018/05/17/python-random/</id>
    <published>2018-05-17T06:21:50.494Z</published>
    <updated>2017-03-15T05:27:30.218Z</updated>
    
    <content type="html"><![CDATA[<p>最近在使用python的随机数，所以总结一下。</p><h1 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h1><p>​    <strong>import random</strong></p><h1 id="具体的函数"><a href="#具体的函数" class="headerlink" title="具体的函数"></a>具体的函数</h1><ul><li><p>random.random() </p><p>随机生成一个0-1之间浮点数</p></li><li><p>random.uniform(a, b)</p><p>生成[a, b]之间的均匀分布的随机数</p></li><li><p>random.randint(a, b)</p><p>生成[a, b]之间的随机的整数</p></li><li><p>random.randrange(start, stop, step)</p><p>生成[start : step : stop]这个数列中的随机一个数。</p><p>特例：若step为偶数，start为偶数，则随机生成指定范围的偶数；若start为奇数，则生成指定范围内的奇数</p></li><li><p>random.choice(sequence)</p><p>从序列sequence中随机选择一个元素</p></li><li><p>random.shuffle(X)</p><p>打乱列表X的元素顺序</p></li><li><p>random.sample(X, k)</p><p>从列表X中随机选取K个数</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在使用python的随机数，所以总结一下。&lt;/p&gt;
&lt;h1 id=&quot;导入包&quot;&gt;&lt;a href=&quot;#导入包&quot; class=&quot;headerlink&quot; title=&quot;导入包&quot;&gt;&lt;/a&gt;导入包&lt;/h1&gt;&lt;p&gt;​    &lt;strong&gt;import random&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="python,  random" scheme="http://yoursite.com/tag/python-random/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/05/17/hello-world/"/>
    <id>http://yoursite.com/2018/05/17/hello-world/</id>
    <published>2018-05-17T06:21:50.348Z</published>
    <updated>2017-03-22T06:10:38.377Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h3 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a>显示图片</h3><p>hexo中添加图片的方法<br>1.设置站点配置_config.yml</p><blockquote><p>post_asset_folder: true</p></blockquote><p>2.安装插件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image -- save11</span><br></pre></td></tr></table></figure><p>3 引用图片<br>3.1 利用标签引用</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 &#123;% asset_path slug %&#125;</span><br><span class="line">2 &#123;% asset_img slug [title] %&#125;</span><br><span class="line">3 &#123;% asset_link slug [title] %&#125;123123</span><br></pre></td></tr></table></figure><p>3.2 利用makdown</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">![例子](例子.png)11</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Caffe安装新坑</title>
    <link href="http://yoursite.com/2017/12/06/caffe_install/"/>
    <id>http://yoursite.com/2017/12/06/caffe_install/</id>
    <published>2017-12-06T11:42:45.000Z</published>
    <updated>2018-03-02T07:17:07.602Z</updated>
    
    <content type="html"><![CDATA[<p>#写在前面的话</p><p>今天教研室新进了两台双TITANX的机器。老板大人叫我测一下，机器跑网络的时候声音大不大。本来觉得简单得很，，，毕竟我已经是老手了。但是现实给了我一个小巴掌。。。啪啪作响。。</p><p>遇到三个问题。</p><h2 id="问题一-更新源时出现-404-NotFound"><a href="#问题一-更新源时出现-404-NotFound" class="headerlink" title="问题一 更新源时出现 404 NotFound"></a>问题一 更新源时出现 404 NotFound</h2><p>  <code>sudo apt-get update</code>这句是常用的更新源的命令。但是嘞，这段时间出现了个怪现象，<br>    <code>W: 无法下载 http://ppa.launchpad.net/fcitx-team/nightly/ubuntu/dists/jessie/main/binary-amd64/Packages  404  Not Found</code></p><p><img src="/2017/12/06/caffe_install/fig1.jpg" alt="错误的现象"></p><p>出现了这个状况咋解决了？</p><p>#解决方案：<br>  将对应的PPA删除掉即可</p><p>  使用以下命令切换到对应PPA目录：<br>    <code>cd /etc/apt/sources.list.d</code><br><img src="/2017/12/06/caffe_install/fig2.jpg" alt="解决方案"></p><p>找到上述无法下载的对应PPA目录，即extra-ppas.list，安全起见，用mv命令将该文件添加后缀.bak即可</p><p><img src="/2017/12/06/caffe_install/fig3.jpg" alt="结果"></p><p>这个时候就好了。</p><h2 id="问题二-libopencv-dev的安装"><a href="#问题二-libopencv-dev的安装" class="headerlink" title="问题二 libopencv-dev的安装"></a>问题二 libopencv-dev的安装</h2><p>  安装opencv真的是个大坑。。。我先是用最基本的<code>sudo apt-get install libopencv-dev</code>来安装的。但是嘞，出现了个错误，就是说libatk无法安装。怎么弄都解决不了。</p><p>  后来我安装了aptitude(<code>sudo apt-get install aptitude</code>)<br>  然后利用aptitude 来安装libopencv-dev（<code>sudo aptitude install libopencv-dev</code>）<br>  你还真别说。。。这么一变化，我还就安装成功了。。。。</p><h2 id="问题三-libcudart-so-8-0"><a href="#问题三-libcudart-so-8-0" class="headerlink" title="问题三 libcudart.so.8.0"></a>问题三 libcudart.so.8.0</h2><p>这个问题最好解决。</p><pre><code>`export LD_LIBRARY_PATH=/usr/local/cuda-8.0/lib64:$LD_LIBRARY_PATH export PATH=/usr/local/cuda-8.0/bin:$PATH`</code></pre><p>你还别说，就这3个小问题。。。折腾了我一个下午。。。主要是如何解决问题二。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#写在前面的话&lt;/p&gt;
&lt;p&gt;今天教研室新进了两台双TITANX的机器。老板大人叫我测一下，机器跑网络的时候声音大不大。本来觉得简单得很，，，毕竟我已经是老手了。但是现实给了我一个小巴掌。。。啪啪作响。。&lt;/p&gt;
&lt;p&gt;遇到三个问题。&lt;/p&gt;
&lt;h2 id=&quot;问题一-更新源
      
    
    </summary>
    
    
      <category term="opencv, libatk" scheme="http://yoursite.com/tag/opencv-libatk/"/>
    
  </entry>
  
  <entry>
    <title>Python_file_print</title>
    <link href="http://yoursite.com/2017/05/07/python-file-print/"/>
    <id>http://yoursite.com/2017/05/07/python-file-print/</id>
    <published>2017-05-07T12:52:21.000Z</published>
    <updated>2017-05-07T13:58:25.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>​    最近在重新翻看《Python核心编程(第二版)》，发现之前忽略的一个知识点，就是文件的输出中关于换行符(‘\n’)的处理。于是就想写在这里做个记录。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>大概就是我有一个txt文件，这个时候我要把它的每一行都打印出来，但是我们知道文本的每一行都有一个’\n’换行符。。这就麻烦了。。我们直接上个代码来看看。。</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p><img src="/2017/05/07/python-file-print/file.jpg" alt="file_image"></p><h2 id="正常的文件读取是什么样的呢？"><a href="#正常的文件读取是什么样的呢？" class="headerlink" title="正常的文件读取是什么样的呢？"></a>正常的文件读取是什么样的呢？</h2><p>直接上代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file = open(<span class="string">'index_display.txt'</span>)</span><br><span class="line"><span class="keyword">for</span> eachLine <span class="keyword">in</span> file:</span><br><span class="line">    <span class="keyword">print</span> eachLine</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><h2 id="结果呢："><a href="#结果呢：" class="headerlink" title="结果呢："></a>结果呢：</h2><p><img src="/2017/05/07/python-file-print/result1.jpg" alt="結果一"></p><p>我们可以看到，每两行输出之间都会有一个空行，，这样就太不美观了。也和原始图片不相符。。那么我们怎么修改呢？狠狠简单。</p><h2 id="狠狠简单，，，简单的你都想不到。。。"><a href="#狠狠简单，，，简单的你都想不到。。。" class="headerlink" title="狠狠简单，，，简单的你都想不到。。。"></a>狠狠简单，，，简单的你都想不到。。。</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file = open(<span class="string">'index_display.txt'</span>)</span><br><span class="line">foe eachLine <span class="keyword">in</span> file:</span><br><span class="line">    <span class="keyword">print</span> eachLine,</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><h2 id="這時候的結果呢？"><a href="#這時候的結果呢？" class="headerlink" title="這時候的結果呢？"></a>這時候的結果呢？</h2><p><img src="/2017/05/07/python-file-print/result2.jpg" alt="結果二"></p><p>發現沒有啊？我們僅僅是加了一個小小的逗號。。。哈哈哈就可以完美的解決這個問題了。</p><h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>print语句默认在输出内容末尾后加一个换行符，而在语句后加一个逗号就可以避免这个行为。<code>readline()</code>和<code>readlines()</code>函数不对行里面的空白字符做任何处理，所以我们有必要加上逗号，如果我们省略逗号，那么显示出的文本每行后会有两个换行符，其中一个是输入是附带的，另一个是<code>print</code>语句自动添加。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Python核心编程(第二版)》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;p&gt;​    最近在重新翻看《Python核心编程(第二版)》，发现之前忽略的一个知识点，就是文件的输出中关于换
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tag/Python/"/>
    
  </entry>
  
  <entry>
    <title>Caffe_solver小结</title>
    <link href="http://yoursite.com/2017/03/28/caffe-solver%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2017/03/28/caffe-solver小结/</id>
    <published>2017-03-28T13:19:39.000Z</published>
    <updated>2017-03-28T13:19:39.186Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python之于LMDB初探</title>
    <link href="http://yoursite.com/2017/03/28/python%E4%B9%8B%E4%BA%8ELMDB%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2017/03/28/python之于LMDB初探/</id>
    <published>2017-03-28T05:07:29.000Z</published>
    <updated>2017-03-28T05:41:30.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>这几天做老板的项目，因为大家的数据集简直脏的要我命，我将数据按照SSD的creat_data.sh的方式做成LMDB，然后在处理的时候每次到达一定的迭代次数，就会出现img_channel为1。但是mean_value的channel是3.这就尴尬了啊。。。我完全不知道是哪张图片，而且可想而知，有一张就不可能仅仅就只有一张。。。所以我就想办法处理掉这些错误的图片。于是在处理这个错误的时候我就想将LMDB中数据给一一读出来。于是就有了下面的内容。</p><p><strong>直接放代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.insert(<span class="number">0</span>, <span class="string">"/home/caffe-master/python"</span>)<span class="comment">#将caffepython的加入python路径中，0：是放在PYTHONPATH中的位置,后面就是caffepython的路径。</span></span><br><span class="line"><span class="keyword">import</span> caffe<span class="comment">#上面一句话就是为了这一句不出错</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> lmdb</span><br><span class="line"><span class="keyword">import</span> argparse<span class="comment">#做输入的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parse = argparse.ArgumentParser()<span class="comment">#创建命令行对象</span></span><br><span class="line">    paese.add_argument(<span class="string">'--lmdbpath'</span>)<span class="comment">#添加一个命令</span></span><br><span class="line">    args = parse.parse_args()<span class="comment">#解析命令行</span></span><br><span class="line">    </span><br><span class="line">    env = lmdb.open(args.lmdbpath, readonly=<span class="keyword">True</span>)<span class="comment">#打开LMDB文件，只读。</span></span><br><span class="line">    <span class="keyword">with</span> env.begin() <span class="keyword">as</span> txn:</span><br><span class="line">        cursor = txn.cursor() <span class="comment">#A</span></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> cursor:</span><br><span class="line">            <span class="comment">#print(key, len(value))#value是string类型</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">'key: '</span>,key</span><br><span class="line">            datum = caffe.proto.caffe_pb2.Datum()<span class="comment">#datum类型 #B</span></span><br><span class="line">            datum.ParseFromString(value)<span class="comment">#转化为datum</span></span><br><span class="line">            flat_x = np.fromstring(datum.data, dtype=np.uint8)<span class="comment">#转化为numpy类型 #C</span></span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#.................前面有30571个这样的输出.........................</span></span><br><span class="line">key: <span class="number">00030572</span>_new_data/JPEGImage/IMG_LIANGXJ_028_2.jpg</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><p>下面给出A, B, C 三处的对象所对应的方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> dir(cursor)</span><br><span class="line">[<span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__enter__'</span>, <span class="string">'__exit__'</span>, <span class="string">'__format__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__iter__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'_iter_from'</span>, <span class="string">'close'</span>, <span class="string">'count'</span>, <span class="string">'delete'</span>, <span class="string">'first'</span>, <span class="string">'first_dup'</span>, <span class="string">'get'</span>, <span class="string">'item'</span>, <span class="string">'iternext'</span>, <span class="string">'iternext_dup'</span>, <span class="string">'iternext_nodup'</span>, <span class="string">'iterprev'</span>, <span class="string">'iterprev_dup'</span>, <span class="string">'iterprev_nodup'</span>, <span class="string">'key'</span>, <span class="string">'last'</span>, <span class="string">'last_dup'</span>, <span class="string">'next'</span>, <span class="string">'next_dup'</span>, <span class="string">'next_nodup'</span>, <span class="string">'pop'</span>, <span class="string">'prev'</span>, <span class="string">'prev_dup'</span>, <span class="string">'prev_nodup'</span>, <span class="string">'put'</span>, <span class="string">'putmulti'</span>, <span class="string">'replace'</span>, <span class="string">'set_key'</span>, <span class="string">'set_key_dup'</span>, <span class="string">'set_range'</span>, <span class="string">'set_range_dup'</span>, <span class="string">'value'</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> dir(datum)</span><br><span class="line">[<span class="string">'ByteSize'</span>, <span class="string">'CHANNELS_FIELD_NUMBER'</span>, <span class="string">'Clear'</span>, <span class="string">'ClearExtension'</span>, <span class="string">'ClearField'</span>, <span class="string">'CopyFrom'</span>, <span class="string">'DATA_FIELD_NUMBER'</span>, <span class="string">'DESCRIPTOR'</span>, <span class="string">'DiscardUnknownFields'</span>, <span class="string">'ENCODED_FIELD_NUMBER'</span>, <span class="string">'FLOAT_DATA_FIELD_NUMBER'</span>, <span class="string">'FindInitializationErrors'</span>, <span class="string">'FromString'</span>, <span class="string">'HEIGHT_FIELD_NUMBER'</span>, <span class="string">'HasExtension'</span>, <span class="string">'HasField'</span>, <span class="string">'IsInitialized'</span>, <span class="string">'LABEL_FIELD_NUMBER'</span>, <span class="string">'ListFields'</span>, <span class="string">'MergeFrom'</span>, <span class="string">'MergeFromString'</span>, <span class="string">'ParseFromString'</span>, <span class="string">'RegisterExtension'</span>, <span class="string">'SerializePartialToString'</span>, <span class="string">'SerializeToString'</span>, <span class="string">'SetInParent'</span>, <span class="string">'WIDTH_FIELD_NUMBER'</span>, <span class="string">'WhichOneof'</span>, <span class="string">'_InternalParse'</span>, <span class="string">'_InternalSerialize'</span>, <span class="string">'_Modified'</span>, <span class="string">'_SetListener'</span>, <span class="string">'_UpdateOneofState'</span>, <span class="string">'__class__'</span>, <span class="string">'__deepcopy__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__getstate__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__metaclass__'</span>, <span class="string">'__module__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__setstate__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__slots__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__unicode__'</span>, <span class="string">'__weakref__'</span>, <span class="string">'_cached_byte_size'</span>, <span class="string">'_cached_byte_size_dirty'</span>, <span class="string">'_decoders_by_tag'</span>, <span class="string">'_extensions_by_name'</span>, <span class="string">'_extensions_by_number'</span>, <span class="string">'_fields'</span>, <span class="string">'_is_present_in_parent'</span>, <span class="string">'_listener'</span>, <span class="string">'_listener_for_children'</span>, <span class="string">'_oneofs'</span>, <span class="string">'_unknown_fields'</span>, <span class="string">'channels'</span>, <span class="string">'data'</span>, <span class="string">'encoded'</span>, <span class="string">'float_data'</span>, <span class="string">'height'</span>, <span class="string">'label'</span>, <span class="string">'width'</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> dir(flat_x)</span><br><span class="line">[<span class="string">'T'</span>, <span class="string">'__abs__'</span>, <span class="string">'__add__'</span>, <span class="string">'__and__'</span>, <span class="string">'__array__'</span>, <span class="string">'__array_finalize__'</span>, <span class="string">'__array_interface__'</span>, <span class="string">'__array_prepare__'</span>, <span class="string">'__array_priority__'</span>, <span class="string">'__array_struct__'</span>, <span class="string">'__array_wrap__'</span>, <span class="string">'__class__'</span>, <span class="string">'__contains__'</span>, <span class="string">'__copy__'</span>, <span class="string">'__deepcopy__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__delitem__'</span>, <span class="string">'__delslice__'</span>, <span class="string">'__div__'</span>, <span class="string">'__divmod__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__float__'</span>, <span class="string">'__floordiv__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__getitem__'</span>, <span class="string">'__getslice__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__hex__'</span>, <span class="string">'__iadd__'</span>, <span class="string">'__iand__'</span>, <span class="string">'__idiv__'</span>, <span class="string">'__ifloordiv__'</span>, <span class="string">'__ilshift__'</span>, <span class="string">'__imod__'</span>, <span class="string">'__imul__'</span>, <span class="string">'__index__'</span>, <span class="string">'__init__'</span>, <span class="string">'__int__'</span>, <span class="string">'__invert__'</span>, <span class="string">'__ior__'</span>, <span class="string">'__ipow__'</span>, <span class="string">'__irshift__'</span>, <span class="string">'__isub__'</span>, <span class="string">'__iter__'</span>, <span class="string">'__itruediv__'</span>, <span class="string">'__ixor__'</span>, <span class="string">'__le__'</span>, <span class="string">'__len__'</span>, <span class="string">'__long__'</span>, <span class="string">'__lshift__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__mod__'</span>, <span class="string">'__mul__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__neg__'</span>, <span class="string">'__new__'</span>, <span class="string">'__nonzero__'</span>, <span class="string">'__oct__'</span>, <span class="string">'__or__'</span>, <span class="string">'__pos__'</span>, <span class="string">'__pow__'</span>, <span class="string">'__radd__'</span>, <span class="string">'__rand__'</span>, <span class="string">'__rdiv__'</span>, <span class="string">'__rdivmod__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__rfloordiv__'</span>, <span class="string">'__rlshift__'</span>, <span class="string">'__rmod__'</span>, <span class="string">'__rmul__'</span>, <span class="string">'__ror__'</span>, <span class="string">'__rpow__'</span>, <span class="string">'__rrshift__'</span>, <span class="string">'__rshift__'</span>, <span class="string">'__rsub__'</span>, <span class="string">'__rtruediv__'</span>, <span class="string">'__rxor__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__setitem__'</span>, <span class="string">'__setslice__'</span>, <span class="string">'__setstate__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__sub__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__truediv__'</span>, <span class="string">'__xor__'</span>, <span class="string">'all'</span>, <span class="string">'any'</span>, <span class="string">'argmax'</span>, <span class="string">'argmin'</span>, <span class="string">'argpartition'</span>, <span class="string">'argsort'</span>, <span class="string">'astype'</span>, <span class="string">'base'</span>, <span class="string">'byteswap'</span>, <span class="string">'choose'</span>, <span class="string">'clip'</span>, <span class="string">'compress'</span>, <span class="string">'conj'</span>, <span class="string">'conjugate'</span>, <span class="string">'copy'</span>, <span class="string">'ctypes'</span>, <span class="string">'cumprod'</span>, <span class="string">'cumsum'</span>, <span class="string">'data'</span>, <span class="string">'diagonal'</span>, <span class="string">'dot'</span>, <span class="string">'dtype'</span>, <span class="string">'dump'</span>, <span class="string">'dumps'</span>, <span class="string">'fill'</span>, <span class="string">'flags'</span>, <span class="string">'flat'</span>, <span class="string">'flatten'</span>, <span class="string">'getfield'</span>, <span class="string">'imag'</span>, <span class="string">'item'</span>, <span class="string">'itemset'</span>, <span class="string">'itemsize'</span>, <span class="string">'max'</span>, <span class="string">'mean'</span>, <span class="string">'min'</span>, <span class="string">'nbytes'</span>, <span class="string">'ndim'</span>, <span class="string">'newbyteorder'</span>, <span class="string">'nonzero'</span>, <span class="string">'partition'</span>, <span class="string">'prod'</span>, <span class="string">'ptp'</span>, <span class="string">'put'</span>, <span class="string">'ravel'</span>, <span class="string">'real'</span>, <span class="string">'repeat'</span>, <span class="string">'reshape'</span>, <span class="string">'resize'</span>, <span class="string">'round'</span>, <span class="string">'searchsorted'</span>, <span class="string">'setfield'</span>, <span class="string">'setflags'</span>, <span class="string">'shape'</span>, <span class="string">'size'</span>, <span class="string">'sort'</span>, <span class="string">'squeeze'</span>, <span class="string">'std'</span>, <span class="string">'strides'</span>, <span class="string">'sum'</span>, <span class="string">'swapaxes'</span>, <span class="string">'take'</span>, <span class="string">'tobytes'</span>, <span class="string">'tofile'</span>, <span class="string">'tolist'</span>, <span class="string">'tostring'</span>, <span class="string">'trace'</span>, <span class="string">'transpose'</span>, <span class="string">'var'</span>, <span class="string">'view'</span>]</span><br></pre></td></tr></table></figure><h1 id="写在后面的话"><a href="#写在后面的话" class="headerlink" title="写在后面的话"></a>写在后面的话</h1><p>在这一次我只查看了datum的channels性质。但是后来我发现所有的datum的channels都是0(ssd在创建LMDB的时候有一个encode选项，，后来我查看了ImageNet的LMDB的channels确实是3).。。。。这就尴尬了。。。还是没有办法解决问题。后来我将batchsize调整为1，每迭代一次就打印出结果，，这样。。。找到了对应的错误图片，然后我将对应的人的所有图片全部删除了。现在搞定了。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;p&gt;这几天做老板的项目，因为大家的数据集简直脏的要我命，我将数据按照SSD的creat_data.sh的方式做成
      
    
    </summary>
    
    
      <category term="Python, LMDB" scheme="http://yoursite.com/tag/Python-LMDB/"/>
    
  </entry>
  
  <entry>
    <title>Python写caffe层</title>
    <link href="http://yoursite.com/2017/03/22/Python%E5%86%99caffe%E5%B1%82/"/>
    <id>http://yoursite.com/2017/03/22/Python写caffe层/</id>
    <published>2017-03-22T02:08:22.000Z</published>
    <updated>2017-03-22T11:28:37.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>因为工作需要，需要用Python写新层，正好也看过这方面的工作。今天就来小小的记录一下，以免自己忘记了。</p><p>Python写层最多的是看到些数据层。所以我们今天就写一个数据层的例子。我们一共分3步走。</p><h2 id="步奏一：写新层"><a href="#步奏一：写新层" class="headerlink" title="步奏一：写新层"></a>步奏一：写新层</h2><p>​    </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#！-*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#author = Cqs</span></span><br><span class="line"><span class="comment">#FileName: MyPythonLayer.py  #1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> caffe</span><br><span class="line"><span class="keyword">import</span> yaml, glob</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> shuffle</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPythonLayer</span><span class="params">(caffe.Layer)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    reshape images</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span><span class="params">(self, bottom, top)</span>:</span></span><br><span class="line">        params_str = self.param_str.split(<span class="string">','</span>)</span><br><span class="line">        params = [yaml.load(item) <span class="keyword">for</span> item <span class="keyword">in</span> params_str] <span class="comment">#2</span></span><br><span class="line">        <span class="keyword">print</span> params</span><br><span class="line">        self.source = params[<span class="number">0</span>][<span class="string">'source_dir'</span>]</span><br><span class="line">        self.target_size = params[<span class="number">1</span>][<span class="string">'target_size'</span>]</span><br><span class="line">        self.batch_size = params[<span class="number">2</span>][<span class="string">'batch_size'</span>]<span class="comment">#3</span></span><br><span class="line">        self.batch_loader = BatchLoader(source_dir=self.source, target_size=self.target_size)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Parameter batch_size:&#123;&#125;\n'</span> \</span><br><span class="line">              <span class="string">'source_dir:&#123;&#125;\n'</span> \</span><br><span class="line">              <span class="string">'target_size:&#123;&#125;'</span>.format(self.batch_size, self.source, self.target_size)</span><br><span class="line">        top[<span class="number">0</span>].reshape(self.batch_size, self.target_size, self.target_size, <span class="number">3</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reshape</span><span class="params">(self, bottom, top)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, bottom, top)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(self.batch_size):</span><br><span class="line">            top[<span class="number">0</span>].data[i, ...] = self.batch_loader.next_batch()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">(self, bottom, propagate_down, top)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BatchLoader</span><span class="params">(object)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, source_dir, target_size)</span>:</span></span><br><span class="line">    self.cur = <span class="number">0</span></span><br><span class="line">    self.target_size = target_size</span><br><span class="line">    self.indexlist = glob.glob(source_dir+ <span class="string">'/*.jpg'</span>)<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next_batch</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.cur == len(self.indexlist):</span><br><span class="line">            self.cur = <span class="number">0</span></span><br><span class="line">            shuffle(self.indexlist)</span><br><span class="line">        item = self.indexlist[self.cur]</span><br><span class="line">        img_tmp = cv2.imread(item)</span><br><span class="line">        img_tmp = cv2.resize(src=img_tmp, dsize=(self.target_size, self.target_size))</span><br><span class="line">        self.cur += <span class="number">1</span></span><br><span class="line">        logging.info(<span class="string">'load &#123;&#125; images'</span>.format(self.cur))</span><br><span class="line">        <span class="keyword">return</span> img_tmp</span><br></pre></td></tr></table></figure><p>​    <strong>代码解释：</strong>#1 处是脚本的名字，这个名字在网络定义文件prototxt中会用到。</p><p>​               #2 处的yaml的使用是解析str。<code>str</code>必须以空格间隔，比如”‘batch_size’: 50”, ‘batch_size’: 与50以空格间           隔，反之会报错，这里因为有多个,我不会解析多个对，因此提前将其<code>split</code>,分而治之。</p><p>​              #3处的参数的顺序很重要，网络定义的prototxt的参数的顺序要根据这个来。</p><p>​              #4处的glob.glob(source_dir+ ‘/*.jpg’)返回的是一个list,是source_dir文件夹下的所有jpg文件的绝对路径。</p><p>​    <strong>代码位置</strong>：一般我写的Python层都会放在caffe-master/Python/caffe文件夹下面。这样可以直接找到。</p><p>(有时候可能找不到你写的这个新的层，那么你可以添加如下代码：)</p><p>import sys</p><p>sys.path.append(‘存放模块的文件夹’)</p><p>上面这段代码的意思就是将该模块放到PATHONPATH中</p><p>​    <strong>代码格式</strong>：</p><p>​                        class myPythonLayer(caffe.Layer):</p><p>​                            def setup(self, bottom, top):</p><p>​                            def reshape(self, bottom, top):</p><p>​                            def forward(self, bottom, top):</p><p>​                            def backward(self, bottom, propagate, top):</p><p>可以看到新层是继承caffe.Layer的，这是必须的。同时，大部分层包含四个方法，分别是setup, reshape, forward, backward.这四个函数。setup是对层的初始化过程,当层被调用的时候，会调用方法forward.</p><ul><li><p>top必须被reshape,否则在blob.cpp中的CHECK(data_)的报错。</p></li><li><p>forward应该是必须的。但是backward可以不是必须的。因为网络必须要有前向操作但是可以没有反向传播。</p></li><li><p>注意forward和backward 两个方法的参数</p><p>​</p></li></ul><h2 id="步骤二：生成prototxt"><a href="#步骤二：生成prototxt" class="headerlink" title="步骤二：生成prototxt"></a>步骤二：生成prototxt</h2><p>本来可以用Python直接生成prototxt的。但是我这里遇到了带你问题，我这里还是直接给出prototxt吧。下次博客再给出Python代码生成prototxt的方法吧。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#file_name = mylayer.prototxt</span></span><br><span class="line">layer&#123;</span><br><span class="line">name:<span class="string">'mylayer'</span></span><br><span class="line">type:<span class="string">'Python'</span></span><br><span class="line">top:<span class="string">'images'</span></span><br><span class="line">python_param&#123;</span><br><span class="line">    module:<span class="string">'MyPythonLayer'</span></span><br><span class="line">    layer:<span class="string">'myPythonLayer'</span></span><br><span class="line">    param_str:<span class="string">"'source_dir': '/home/amax/cqs/caffe-master/example/Cqs/data','target_size': 100,'batch_size': 200"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2017/03/22/Python写caffe层/net.png" alt="网络框图"></p><p><strong>解释：</strong></p><ol><li>我们用Python写的层的type都是’python’.</li><li>pathon_param要给出模块的名字，也就是我们写的新层的文件的名字，而layer就是我们的新层的名字。这里要注意param_str的顺序。</li></ol><h2 id="步奏三：调用运行"><a href="#步奏三：调用运行" class="headerlink" title="步奏三：调用运行"></a>步奏三：调用运行</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">！<span class="comment">#-*- coding: utf-8 -*-</span></span><br><span class="line">author = Cqs</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> future <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> caffe</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    net = caffe.Net(<span class="string">'mylayer.prototxt'</span>, caffe.TEST)</span><br><span class="line">    net.forward()</span><br><span class="line">    images = net.blobs[<span class="string">'images'</span>].data</span><br><span class="line">    print(images.shape)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/usr/bin/python2<span class="number">.7</span> /home/amax/cqs/caffe-master/examples/Cqs/test.py</span><br><span class="line">WARNING: Logging before InitGoogleLogging() <span class="keyword">is</span> written to STDERR</span><br><span class="line">[&#123;<span class="string">'source_dir'</span>: <span class="string">'/home/amax/cqs/caffe-master/examples/Cqs/data'</span>&#125;, &#123;<span class="string">'batch_size'</span>: <span class="number">200</span>&#125;, &#123;<span class="string">'target_size'</span>: <span class="number">100</span>&#125;]</span><br><span class="line">I0322 <span class="number">13</span>:<span class="number">53</span>:<span class="number">32.455627</span> <span class="number">36217</span> net.cpp:<span class="number">51</span>] Initializing net <span class="keyword">from</span> parameters: </span><br><span class="line">Parameter batch_size:<span class="number">200</span></span><br><span class="line">state &#123;</span><br><span class="line">source_dir:/home/amax/cqs/caffe-master/examples/Cqs/data</span><br><span class="line">  phase: TEST</span><br><span class="line">target_size:<span class="number">100</span></span><br><span class="line">  level: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">layer &#123;</span><br><span class="line">  name: <span class="string">"mylayer"</span></span><br><span class="line">  type: <span class="string">"Python"</span></span><br><span class="line">  top: <span class="string">"images"</span></span><br><span class="line">  python_param &#123;</span><br><span class="line">module: <span class="string">"MyPythonLayer"</span></span><br><span class="line">layer: <span class="string">"myPythonLayer"</span></span><br><span class="line">param_str: <span class="string">" \'source_dir\': /home/amax/cqs/caffe-master/examples/Cqs/data, \'batch_size\': 200, \'target_size\': 100 "</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">I0322 <span class="number">13</span>:<span class="number">53</span>:<span class="number">32.455687</span> <span class="number">36217</span> layer_factory.hpp:<span class="number">77</span>] Creating layer mylayer</span><br><span class="line">I0322 <span class="number">13</span>:<span class="number">53</span>:<span class="number">32.456166</span> <span class="number">36217</span> net.cpp:<span class="number">84</span>] Creating Layer mylayer</span><br><span class="line">I0322 13:53:32.456177 36217 net.cpp:380] mylayer -&gt; images</span><br><span class="line">I0322 <span class="number">13</span>:<span class="number">53</span>:<span class="number">32.457883</span> <span class="number">36217</span> net.cpp:<span class="number">122</span>] Setting up mylayer</span><br><span class="line">I0322 <span class="number">13</span>:<span class="number">53</span>:<span class="number">32.457898</span> <span class="number">36217</span> net.cpp:<span class="number">129</span>] Top shape: <span class="number">200</span> <span class="number">100</span> <span class="number">100</span> <span class="number">3</span> (<span class="number">6000000</span>)</span><br><span class="line">I0322 <span class="number">13</span>:<span class="number">53</span>:<span class="number">32.457903</span> <span class="number">36217</span> net.cpp:<span class="number">137</span>] Memory required <span class="keyword">for</span> data: <span class="number">24000000</span></span><br><span class="line">I0322 <span class="number">13</span>:<span class="number">53</span>:<span class="number">32.457908</span> <span class="number">36217</span> net.cpp:<span class="number">200</span>] mylayer does <span class="keyword">not</span> need backward computation.</span><br><span class="line">I0322 <span class="number">13</span>:<span class="number">53</span>:<span class="number">32.457912</span> <span class="number">36217</span> net.cpp:<span class="number">242</span>] This network produces output images</span><br><span class="line">I0322 <span class="number">13</span>:<span class="number">53</span>:<span class="number">32.457917</span> <span class="number">36217</span> net.cpp:<span class="number">255</span>] Network initialization done.</span><br><span class="line">INFO:root:load /home/amax/cqs/caffe-master/examples/Cqs/data/<span class="number">000001.j</span>pg images</span><br><span class="line">INFO:root:load /home/amax/cqs/caffe-master/examples/Cqs/data/<span class="number">000002.j</span>pg images</span><br><span class="line">INFO:root:load /home/amax/cqs/caffe-master/examples/Cqs/data/<span class="number">000003.j</span>pg images</span><br><span class="line">................................<span class="number">.196</span>个输出.............................................</span><br><span class="line">INFO:root:load /home/amax/cqs/caffe-master/examples/Cqs/data/<span class="number">000015.j</span>pg images</span><br><span class="line">(<span class="number">200</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">3</span>)</span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>Reference</strong></p><p><a href="https://saicoco.github.io/pycaffe/" target="_blank" rel="noopener">参考一</a></p><p><a href="http://www.voidcn.com/blog/eagelangel/article/p-6119936.html" target="_blank" rel="noopener">参考二</a></p><p><a href="http://pyyaml.org/wiki/PyYAMLDocumentation" target="_blank" rel="noopener">参考三</a></p><p><a href="http://blog.xiayf.cn/2013/01/26/python-string-format/" target="_blank" rel="noopener">参考四</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;p&gt;因为工作需要，需要用Python写新层，正好也看过这方面的工作。今天就来小小的记录一下，以免自己忘记了。&lt;/
      
    
    </summary>
    
    
      <category term="python, caffe" scheme="http://yoursite.com/tag/python-caffe/"/>
    
  </entry>
  
  <entry>
    <title>Test</title>
    <link href="http://yoursite.com/2017/03/21/test/"/>
    <id>http://yoursite.com/2017/03/21/test/</id>
    <published>2017-03-21T10:46:51.000Z</published>
    <updated>2017-03-21T10:47:57.636Z</updated>
    
    <content type="html"><![CDATA[<p>就为了做个测试。</p><p><img src="/2017/03/21/test/test.jpg" alt="测试"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;就为了做个测试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2017/03/21/test/test.jpg&quot; alt=&quot;测试&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="test" scheme="http://yoursite.com/tag/test/"/>
    
  </entry>
  
  <entry>
    <title>Python创建exe文件</title>
    <link href="http://yoursite.com/2017/03/21/python-to-exe/"/>
    <id>http://yoursite.com/2017/03/21/python-to-exe/</id>
    <published>2017-03-21T08:25:32.000Z</published>
    <updated>2017-03-22T06:12:52.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>这两天用Python写了一个图片打标签的工具，然后将它包装成了exe文件。在这里记录一下，生成exe的方法。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>py2exe是一个将Python脚本转化成windows上的可独立执行的程序(*.exe)的工具。这样我们就可以不用装Python而在windows上运行这个可执行程序。</p><p>py2exe已经被用于创建wxPython,Tkinter,Pmw,PyGTK,pygame,win32com client server。和其他的独立程序。py2exe是发布在开源许可证下的。</p><h2 id="安装py2exe"><a href="#安装py2exe" class="headerlink" title="安装py2exe"></a>安装py2exe</h2><p>从<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#imread" target="_blank" rel="noopener">网站</a>可以下载到py2exe‑0.6.10a1‑cp27‑none‑win_amd64.whl。然后可以使用pip install 安装。</p><h2 id="py2exe的使用"><a href="#py2exe的使用" class="headerlink" title="py2exe的使用"></a>py2exe的使用</h2><p>假设我们有一个脚本：image_labeling.py的python脚本。现在打算将他们转化为exe文件。首先创建一个mysetup.py的脚本。如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mysetup.py</span></span><br><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">import</span> py2exe</span><br><span class="line">setup(console=[<span class="string">"image_labeling.py"</span>])</span><br></pre></td></tr></table></figure><p>运行方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python mysetup.py py2exe</span><br></pre></td></tr></table></figure><p><img src="/2017/03/21/python-to-exe/exe.png" alt="生成的文件"></p><p><img src="/2017/03/21/python-to-exe/ruanjian.png" alt="软件界面V1"></p><p>上面的命令执行后将产生一个名为dist的子目录，其中包含了myscript.exe, python24.dll, library.zip这些文件。<br>如果你的myscript.py脚本中用了已编译的C扩展模块，那么这些模块也会被拷贝在个子目录中，同样，所有的dll文件在运行时都是需要的，除了系统的dll文件。<br>dist子目录中的文件包含了你的程序所必须的东西，你应将这个子目录中的所有内容一起发布。</p><p>默认情况下，py2exe在目录dist下创建以下这些必须的文件：<br>1、一个或多个exe文件。<br>2、python##.dll。<br>3、几个.pyd文件，它们是已编译的扩展名，它们是exe文件所需要的；加上其它的.dll文件，这些.dll是.pyd所需要的。<br>4、一个library.zip文件，它包含了已编译的纯的python模块如.pyc或.pyo<br>上面的mysetup.py创建了一个控制台的myscript.exe程序，如果你要创建一个图形用户界的程序，那么你只需要将mysetup.py中的console=[“myscript.py”]替换为windows=[“myscript.py”]既可。</p><p>py2exe一次能够创建多个exe文件，你需要将这些脚本文件的列表传递给console或windows的关键字参数。如果你有几个相关联的脚本，那么这是很有用的。<br>运行下面个命令，将显示py2exe命令的所有命令行标记。<br><code>python mysetup.py py2exe --help</code></p><h2 id="指定额外的文件"><a href="#指定额外的文件" class="headerlink" title="指定额外的文件"></a>指定额外的文件</h2><p>一些应用程序在运行时需要额外的文件，诸如配置文件、字体、位图。<br>如果在安装脚本中用data_files可选项指定了那些额外的文件，那么py2exe能将这些文件拷贝到dist子目录中。data_files应包含一个元组(target-dir, files)列表，其中的files是这些额外的文件的列表。<br>示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mysetup.py</span></span><br><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> py2exe</span><br><span class="line"></span><br><span class="line">setup(console=[<span class="string">"myscript.py"</span>],</span><br><span class="line">       data_files=[(<span class="string">"bitmaps"</span>,</span><br><span class="line">                    [<span class="string">"bm/large.gif"</span>, <span class="string">"bm/small.gif"</span>]),</span><br><span class="line">                   (<span class="string">"fonts"</span>,</span><br><span class="line">                    glob.glob(<span class="string">"fonts\\*.fnt"</span>))],</span><br></pre></td></tr></table></figure><p>说明：data_files选项将创建一个子目录dist\bitmaps，其中包含两个.gif文件；一个子目录dist\fonts，其中包含了所有的.fnt文件。</p><h2 id="Windows-NT-services"><a href="#Windows-NT-services" class="headerlink" title="Windows NT services"></a>Windows NT services</h2><p>你可以通过传递一个service关键字参数给setup函数来建造Windows NT services<br>,这个service参数的值必须是一个Python模块名(包含一service类)的列表。<br>示例如下：</p><p><code>mysetup.py</code></p><p><code>from distutils.core import setup</code><br><code>import py2exe</code></p><p><code>setup(service=[&quot;MyService&quot;])</code><br>所建造的可执行的service是可以通过在其后跟一定的命令行参数标记来自行安装和卸载的。你可以通过在这个可执行的service(exe)后跟一-help参数来得到更多的帮助。</p><h2 id="COM-servers"><a href="#COM-servers" class="headerlink" title="COM servers"></a>COM servers</h2><p>你可以通过传递一个com_server 关键字参数给setup函数来建造Windows NT services<br>,这个service参数的值必须是一个Python模块名(包含一个或多个COM server 类)的列表。<br>示例如下：</p><p><code>mysetup.py</code></p><p><code>from distutils.core import setup</code><br><code>import py2exe</code></p><p><code>setup(com_server=[&quot;win32com.server.interp&quot;])</code><br>默认情况下，DLL和EXE servers被建造，你不需要它们的话你可以简单的删除它们。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="http://www.cnblogs.com/rj81/p/5495191.html" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;p&gt;这两天用Python写了一个图片打标签的工具，然后将它包装成了exe文件。在这里记录一下，生成exe的方法。
      
    
    </summary>
    
    
      <category term="python exe" scheme="http://yoursite.com/tag/python-exe/"/>
    
  </entry>
  
  <entry>
    <title>Object_detection_NMS</title>
    <link href="http://yoursite.com/2017/03/19/Object_detection_NMS/"/>
    <id>http://yoursite.com/2017/03/19/Object_detection_NMS/</id>
    <published>2017-03-19T08:27:06.000Z</published>
    <updated>2018-03-02T07:16:50.586Z</updated>
    
    <content type="html"><![CDATA[<p>#写在前面的话</p><p>​    虽然一直标榜自己是做目标检测的。但是一直也没来总结一下目标检测的细节。打算写一个系列，来好好研究一下faster-rcnn的代码。今天就来先记录一下非极大抑制(NMS)算法。</p><p><strong>Non-maximum suppression（非极大抑制）</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nms</span><span class="params">(dets, thresh)</span>:</span></span><br><span class="line">    x1 = dets[:, <span class="number">0</span>]</span><br><span class="line">    y1 = dets[:, <span class="number">1</span>]</span><br><span class="line">    x2 = dets[:, <span class="number">2</span>]</span><br><span class="line">    y2 = dets[:, <span class="number">3</span>]</span><br><span class="line">    scores = dets[:, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">    areas = (x2 - x1 + <span class="number">1</span>) * (y2 - y1 + <span class="number">1</span>)</span><br><span class="line">    order = scores.argsort()[::<span class="number">-1</span>] <span class="comment"># 降序排序，返回索引</span></span><br><span class="line"></span><br><span class="line">    keep = []</span><br><span class="line">    <span class="keyword">while</span> order.size &gt; <span class="number">0</span>:</span><br><span class="line">        i = order[<span class="number">0</span>]</span><br><span class="line">        keep.append(i)</span><br><span class="line">        xx1 = np.maximum(x1[i], x1[order[<span class="number">1</span>:]])<span class="comment">#比较x1[i]与x1[order[1:]]中每一个值返回最大值</span></span><br><span class="line">        yy1 = np.maximum(y1[i], y1[order[<span class="number">1</span>:]])<span class="comment">#例子：</span></span><br><span class="line">        xx2 = np.minimum(x2[i], x2[order[<span class="number">1</span>:]])<span class="comment">#np.minimum(2, [1, 3, 6])  返回:array([2, 3, 6])</span></span><br><span class="line">        yy2 = np.minimum(y2[i], y2[order[<span class="number">1</span>:]])</span><br><span class="line"></span><br><span class="line">        w = np.maximum(<span class="number">0.0</span>, xx2 - xx1 + <span class="number">1</span>)</span><br><span class="line">        h = np.maximum(<span class="number">0.0</span>, yy2 - yy1 + <span class="number">1</span>)</span><br><span class="line">        inter = w * h</span><br><span class="line">        ovr = inter / (areas[i] + areas[order[<span class="number">1</span>:]] - inter)</span><br><span class="line"></span><br><span class="line">        inds = np.where(ovr &lt;= thresh)[<span class="number">0</span>]</span><br><span class="line">        order = order[inds + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> keep</span><br></pre></td></tr></table></figure><p>这段代码来自RBG大神。</p><p>dets中每一个元素都是一个5维向量，是[X1, Y1, X2, Y2, score], 前四位是坐标，后一位是目标的置信度。</p><p>利用scores可以得到boundingbox的优先度，然后保留优先度最大的box,然后寻找与之IOU小于阈值的bbox,然后保留下来，然后再选择余下来的bbox的优先度最大的bbox,再进行比较。直到没有bbox可以比较了为止。</p><p><img src="/2017/03/19/Object_detection_NMS/NMS.png" alt="NMS"></p><p>一共有6个识别为人的框，每一个框有一个置信率，现在需要消除多余的框：　　</p><ul><li>按置信率排序：0.95, 0.9, 0.9, 0.8, 0.7, 0.7</li><li>取最大0.95的框为一个物体框</li><li>剩余5个框中，去掉与0.95框重叠率大于0.6的框，则保留0.9, 0.8, 0.7三个框</li><li>重复上面三个步骤，　知道没有框了，0.9为一个框</li><li>选出来的为0.95, 0.9</li></ul><p><strong>Reference</strong></p><p><a href="https://saicoco.github.io/object-detection-1/" target="_blank" rel="noopener">参考一</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#写在前面的话&lt;/p&gt;
&lt;p&gt;​    虽然一直标榜自己是做目标检测的。但是一直也没来总结一下目标检测的细节。打算写一个系列，来好好研究一下faster-rcnn的代码。今天就来先记录一下非极大抑制(NMS)算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Non-maximum su
      
    
    </summary>
    
    
      <category term="python, object_detection" scheme="http://yoursite.com/tag/python-object-detection/"/>
    
  </entry>
  
  <entry>
    <title>Genetic_Algorithms</title>
    <link href="http://yoursite.com/2017/03/19/Genetic-Algorithms/"/>
    <id>http://yoursite.com/2017/03/19/Genetic-Algorithms/</id>
    <published>2017-03-19T05:39:08.000Z</published>
    <updated>2017-03-19T08:22:51.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>因为打算用遗传算法来优化深度神经网络的训练过程，所以，这两天熟悉了一下遗传算法(Genetic algorithms)，这里就来简要的记录一下这两天的学习。</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a><a href="https://zh.wikipedia.org/wiki/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">算法</a></h1><p>遗传算法(genetic algorithm (GA))是计算机数学中用于解决最优化的搜索算法，是进化算法的一种。</p><p>遗传算法通常实现方式为一种计算机模拟。对于一个最优化问题，一定数量的候选解(个体)可以抽象表示为染色体，使得种群向更好的解进化。传统上，解用二进制表示(0和1的串)，但是也可以用其他的表示方法。进化从完全随机个体的种群开始，之后一代一代发生。在每一代中评价整个种群的适应度，从当前种群中随机选择多个个体(基于他们的适应度)。通过自然选择和突变产生新的生命种群，该种群在算法的下一次迭代中成为当前种群。</p><h2 id="算法流程图"><a href="#算法流程图" class="headerlink" title="算法流程图"></a>算法流程图</h2><p><img src="/2017/03/19/Genetic-Algorithms/flow_chart.jpg" alt="算法流程图"></p><h2 id="算法细节"><a href="#算法细节" class="headerlink" title="算法细节"></a>算法细节</h2><ul><li>编码–&gt;创造染色体</li><li>个体–&gt;种群</li><li>适应度函数</li><li>遗传算子<ul><li>选择</li><li>交叉</li><li>变异</li></ul></li><li>运行参数<ul><li>是否选择精英操作</li><li>种群大小</li><li>染色体长度</li><li>最大迭代次数</li><li>交叉概率</li><li>变异概率</li></ul></li></ul><h3 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h3><p>实现遗传算法的第一步就是明确求解问题的解码和编码方式</p><p>对于函数优化问题，一般有两种编码方式，各具优缺点</p><ul><li>实数编码： 直接用实数表示基因，容易理解且不需要解码过程，但是容易过早收敛，从而陷入局部最优</li><li>二进制编码： 稳定性高，种群多样性大，但需要的存储空间大，需要解码且难以理解</li></ul><h3 id="个体与种群"><a href="#个体与种群" class="headerlink" title="个体与种群"></a>个体与种群</h3><p>染色体表达了某种特征，这种特征的载体，称为个体。</p><h3 id="适应度函数"><a href="#适应度函数" class="headerlink" title="适应度函数"></a>适应度函数</h3><p>遗传算法中，一个个体的好坏适应度值来评价。</p><p>适应度值越大，解的质量越高。</p><p>适应度函数是遗传算法进化的驱动力，也是进行自然选择的唯一标准，他的设计应结合求解问题本身的要求而定。</p><h3 id="遗传算子"><a href="#遗传算子" class="headerlink" title="遗传算子"></a>遗传算子</h3><p>我们希望有这样一个种群，它所包含的个体所对应的函数的最值，但是这个种群一开始可能不那么优秀，因为个体的染色体串是随机生成的。</p><p>如何让种群变得优秀呢？</p><p>不断的进化。</p><p>每一次进化都尽可能保留种群中的优秀个体，淘汰掉不理想的个体，并且在优秀个体之间进行染色体交叉，有些个体还可能出现变异。</p><p>种群的每一次进化，都会产生一个最优个体。种群所有世代的最优个体，可能就是函数最值对应的定义域中的点。</p><p>如果种群无休止地进化，那总能找到最好的解。但实际上，我们的时间有限，通常在得到一个看上去不错的解时，便终止了进化。</p><p>对于给定的种群，如何赋予它<strong>进化</strong>的能力呢？</p><ul><li>首先是<strong>选择</strong>(selection)<ul><li>选择操作是从前代种群中选择<strong><em>多对</em></strong>较优个体，一对较优个体称之为一对父母，让父母们将它们的基因传递到下一代，直到下一代个体数量达到种群数量上限</li><li>在选择操作前，将种群中个体按照适应度从小到大进行排列</li><li>采用轮盘赌选择方法（当然还有很多别的选择方法），各个个体被选中的概率与其适应度函数值大小成正比</li><li>轮盘赌选择方法具有随机性，在选择的过程中可能会丢掉较好的个体，所以可以使用精英机制，将前代最优个体直接选择</li></ul></li><li>其次是<strong>交叉</strong>(crossover)<ul><li>两个待交叉的不同的染色体(父母)根据交叉概率(cross_rate)按某种方式交换其部分基因</li><li>采用单点交叉法，也可以使用其他交叉方法</li></ul></li><li>最后是<strong>变异</strong>(mutation)<ul><li>染色体按照变异概率(mutate_rate)进行染色体的变异</li><li>采用单点变异法，也可以使用其他变异方法</li></ul></li></ul><p>一般来说，交叉概率(cross_rate)比较大，变异概率(mutate_rate)极低。像求解函数最大值这类问题，</p><p>因为遗传算法相信2条优秀的父母染色体交叉更有可能产生优秀的后代，而变异的话产生优秀后代的可能性极低，不过也有存在可能一下就变异出非常优秀的后代。这也是符合自然界生物进化的特征的。</p><h2 id="待求解问题"><a href="#待求解问题" class="headerlink" title="待求解问题"></a>待求解问题</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">求解函数 f(x) = x + <span class="number">10</span>*sin(<span class="number">5</span>*x) + <span class="number">7</span>*cos(<span class="number">4</span>*x) 在区间[<span class="number">0</span>,<span class="number">9</span>]的最大值。</span><br></pre></td></tr></table></figure><p><img src="/2017/03/19/Genetic-Algorithms/function.png" alt="function"></p><h3 id="编码和解码"><a href="#编码和解码" class="headerlink" title="编码和解码"></a>编码和解码</h3><p>假如设定求解的精度为小数点后4位，可以将x的解空间划分为 <code>(9-0)×(1e+4)=90000</code>个等分。</p><p><code>2^16&lt;90000&lt;2^17</code>，需要17位二进制数来表示这些解。换句话说，一个解的编码就是一个17位的二进制串。</p><p>一开始，这些二进制串是随机生成的。</p><p>一个这样的二进制串代表一条染色体串，这里染色体串的长度为17。</p><p>对于任何一条这样的染色体chromosome，如何将它复原(解码)到[0,9]这个区间中的数值呢？</p><p>对于本问题，我们可以采用以下公式来解码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">0</span> + decimal(chromosome)×(<span class="number">9</span><span class="number">-0</span>)/(<span class="number">2</span>^<span class="number">17</span><span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>decimal( ): 将二进制数转化为十进制数</p><p>一般化解码公式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f(x), x∈[lower_bound, upper_bound]</span><br><span class="line">x = lower_bound + decimal(chromosome)×(upper_bound-lower_bound)/(<span class="number">2</span>^chromosome_size<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>lower_bound: 函数定义域的下限<br>upper_bound: 函数定义域的上限<br>chromosome_size: 染色体的长度</p><p>通过上述公式，我们就可以成功地将二进制染色体串解码成[0,9]区间中的十进制实数解。</p><h3 id="个体与种群-1"><a href="#个体与种群-1" class="headerlink" title="个体与种群"></a>个体与种群</h3><p>本次实验所要解决的一元函数最大值求解问题，个体可以用上一节构造的染色体表示，一个个体里有一条染色体。</p><p>许多这样的个体组成了一个种群，其含义是一个一维点集(x轴上[0,9]的线段)。</p><h3 id="适应度函数-1"><a href="#适应度函数-1" class="headerlink" title="适应度函数"></a>适应度函数</h3><p>在本问题中，f(x)就是适应度函数。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*- coding=utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">##求解函数 f(x) = x + 10*sin(5*x) + 7*cos(4*x) 在区间[0,9]的最大值。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GA</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, length, count)</span>:</span></span><br><span class="line">        <span class="comment"># 染色体的长度</span></span><br><span class="line">        self.length = length</span><br><span class="line">        <span class="comment"># 种群中染色体的数量</span></span><br><span class="line">        self.count = count</span><br><span class="line">        <span class="comment"># 随机生成及初始种群</span></span><br><span class="line">        self.population = self.gen_population(length, count)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evolve</span><span class="params">(self, retain_rate=<span class="number">0.2</span>, random_select_rate=<span class="number">0.5</span>, mutation_rate=<span class="number">0.01</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        进化</span></span><br><span class="line"><span class="string">        对当前一代种群依次进行选择，交叉并生成新一代种群，然后对新一代的种群进行变异</span></span><br><span class="line"><span class="string">        :param retain_rate:当前一代保留的概率</span></span><br><span class="line"><span class="string">        :param random_select_rate:随机选择适应度虽然小但是幸存下来的概率</span></span><br><span class="line"><span class="string">        :param mutation_rate: 变异的概率</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        parents = self.selection(retain_rate, random_select_rate)</span><br><span class="line">        self.crossover(parents)</span><br><span class="line">        self.mutation(mutation_rate)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">selection</span><span class="params">(self, retain_rate, random_select_rate)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        选择</span></span><br><span class="line"><span class="string">        先对适应度从小到大排序，选出存活的染色体</span></span><br><span class="line"><span class="string">        再进行随机选择，选出适应度虽然小，但是幸存下来的个体</span></span><br><span class="line"><span class="string">        :param retain_rate: 当前一代保留的概率</span></span><br><span class="line"><span class="string">        :param random_select_rate: 随机选择适应度虽然小但是幸存下来的概率</span></span><br><span class="line"><span class="string">        :return: 返回留下来交配的染色体</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#对适应度从小到大排序，选出存活的染色体</span></span><br><span class="line">        grated = [(self.fitness(chromosome),chromosome) <span class="keyword">for</span> chromosome <span class="keyword">in</span> self.population]</span><br><span class="line">        grated = [x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> sorted(grated, reverse=<span class="keyword">True</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#选出适应性强的染色体</span></span><br><span class="line">        retain_length = int(len(grated) * retain_rate)</span><br><span class="line">        parents = grated[:retain_length] <span class="comment"># 选择前retain_length个元素</span></span><br><span class="line">        <span class="comment">#选出适应性不强，但是幸存下来的染色体</span></span><br><span class="line">        <span class="keyword">for</span> chromosome <span class="keyword">in</span> grated[retain_length:]:</span><br><span class="line">            <span class="keyword">if</span> random.random() &lt; random_select_rate:</span><br><span class="line">                parents.append(chromosome)</span><br><span class="line">        <span class="keyword">return</span> parents</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">crossover</span><span class="params">(self, parents)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        染色体的交叉，繁殖，生成新一代的种群</span></span><br><span class="line"><span class="string">        :param parents: 父母</span></span><br><span class="line"><span class="string">        :return: 新一代种群</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#新出生的孩子，最终会被加入存活下来的父母之中，形成新一代的种群。</span></span><br><span class="line">        children =[]</span><br><span class="line">        <span class="comment">#需要繁殖的孩子的量</span></span><br><span class="line">        target_count = len(self.population) - len(parents)</span><br><span class="line">        <span class="comment">#开始根据需要的量进行繁殖</span></span><br><span class="line">        <span class="keyword">while</span> len(children) &lt; target_count:</span><br><span class="line">            male = random.randint(<span class="number">0</span>, len(parents)<span class="number">-1</span>)</span><br><span class="line">            female = random.randint(<span class="number">0</span>,len(parents)<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> male != female:</span><br><span class="line">                <span class="comment">#随机选择交叉点</span></span><br><span class="line">                cross_pos = random.randint(<span class="number">0</span>, self.length)</span><br><span class="line">                <span class="comment">#生成掩码，方便位操作</span></span><br><span class="line">                mask = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> xrange(cross_pos):</span><br><span class="line">                    mask |= (<span class="number">1</span> &lt;&lt; i)</span><br><span class="line">                male = parents[male]</span><br><span class="line">                female = parents[female]</span><br><span class="line">                <span class="comment">#孩子将获得父亲在交叉点前的基因和母亲在交叉点后的(包括交叉点)的基因</span></span><br><span class="line">                child = ((male &amp; mask) | (female &amp; ~mask)) &amp; ((<span class="number">1</span> &lt;&lt; self.length) <span class="number">-1</span>)</span><br><span class="line">                children.append(child)</span><br><span class="line">        <span class="comment">#经过繁殖后，孩子和父母的数量与原始种群的数量相等，在这里可以更新种群</span></span><br><span class="line">        self.population = parents + children</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mutation</span><span class="params">(self, rate)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        变异</span></span><br><span class="line"><span class="string">        对种群中的所有个体，随机改变某个个体中的某个基因</span></span><br><span class="line"><span class="string">        :param rate:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(self.population)):</span><br><span class="line">            <span class="keyword">if</span> random.random() &lt; rate:</span><br><span class="line">                j = random.randint(<span class="number">0</span>, self.length <span class="number">-1</span>)</span><br><span class="line">                self.population[i] ^= <span class="number">1</span> &lt;&lt; j</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gen_chromosome</span><span class="params">(self, length)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        随机生成长度为length的染色体， 每个基因的取值为0或者1</span></span><br><span class="line"><span class="string">        这里用一个bit表示一个基因</span></span><br><span class="line"><span class="string">        :param length: 染色体的长度</span></span><br><span class="line"><span class="string">        :return: 一个长度为length的染色体，每一位为0或者1</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        chromosome = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(length):</span><br><span class="line">            <span class="comment"># 1 &lt;&lt; i ==&gt; 2 ^ i</span></span><br><span class="line">            chromosome |= (<span class="number">1</span> &lt;&lt; i) *  random.randint(<span class="number">0</span>, <span class="number">1</span>) <span class="comment">#x |= 5 ==&gt; x = x | 5</span></span><br><span class="line">        <span class="keyword">return</span> chromosome</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gen_population</span><span class="params">(self, length, count)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取初始种群(一个含有count个长度为length的染色体列表)</span></span><br><span class="line"><span class="string">        :param length: 染色体的长度</span></span><br><span class="line"><span class="string">        :param count: 种群的染色体数量</span></span><br><span class="line"><span class="string">        :return: 一个含有count个长度为length的染色体列表</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> [self.gen_chromosome(length) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(count)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fitness</span><span class="params">(self, chromosome)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        计算适应度， 将染色体解码为0~9之间的数字，带入函数计算</span></span><br><span class="line"><span class="string">        以为求解最大值，所以数值越大，适应度越高</span></span><br><span class="line"><span class="string">        :param chromosome: 染色体</span></span><br><span class="line"><span class="string">        :return: 返回适应度</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        x = self.decode(chromosome)</span><br><span class="line">        <span class="keyword">return</span> x + <span class="number">10</span>*math.sin(<span class="number">5</span>*x) + <span class="number">7</span>*math.cos(<span class="number">4</span>*x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decode</span><span class="params">(self, chromosome)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        解码染色体，将二进制转化为属于[0,9]之间的额实数</span></span><br><span class="line"><span class="string">        :param chromosome: 二进制表达的染色体</span></span><br><span class="line"><span class="string">        :return: [0,9]之间的数字</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> chromosome * <span class="number">9.0</span> / (<span class="number">2</span>**self.length <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">result</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取当前代的最优值，智力取得是函数取最大值的x的值</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        grated = [(self.fitness(chromosome), chromosome) <span class="keyword">for</span> chromosome <span class="keyword">in</span> self.population]</span><br><span class="line">        grated = [x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> sorted(grated, reverse=<span class="keyword">True</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ga.decode(grated[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#染色体长度为17，种群数量为300</span></span><br><span class="line">    ga = GA(<span class="number">17</span>, <span class="number">300</span>)</span><br><span class="line">    </span><br><span class="line">    time1 = time.time()</span><br><span class="line">    <span class="comment">#200次进化diedai</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">200</span>):</span><br><span class="line">        ga.evolve()</span><br><span class="line"></span><br><span class="line">    time2 = time.time()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"结果是： "</span>, ga.result()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"运行时间是："</span>, time2 - time1</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>结果是：  7.85748182283<br>运行时间是： 0.155000209808</p><h1 id="写在后面的话"><a href="#写在后面的话" class="headerlink" title="写在后面的话"></a>写在后面的话</h1><p>现实问题转化到遗传算法是一个难点，也就是如何有效地将现实问题映射到遗传算法个个体上，完成了这一步，后面的三个算子也就是按部就班的事情了。</p><p>遗传算法中有很多参数，比如说，初始种群的数量，交叉概率，变异概率，进化代数等等，这些参数影响算法的收敛速度和收敛值。</p><p>遗传算法是一种仿生算法，类似的算法还有模拟退火算法、粒子群算法、蚁群算法、禁忌搜索，统称为元启发式算法（Meta-heuristic algorithms）这类算法得益于自然界现象的启发，而不是像确定性算法那样的数字论证。</p><h2 id="reference："><a href="#reference：" class="headerlink" title="reference："></a>reference：</h2><p><a href="https://www.zhihu.com/question/23293449" target="_blank" rel="noopener">参考一</a></p><p><a href="https://zh.wikipedia.org/wiki/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">参考二</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;p&gt;因为打算用遗传算法来优化深度神经网络的训练过程，所以，这两天熟悉了一下遗传算法(Genetic algori
      
    
    </summary>
    
    
      <category term="python, Algorithms" scheme="http://yoursite.com/tag/python-Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>python_PIL_matplotlib</title>
    <link href="http://yoursite.com/2017/03/17/python-PIL-matplotlib/"/>
    <id>http://yoursite.com/2017/03/17/python-PIL-matplotlib/</id>
    <published>2017-03-17T07:36:17.000Z</published>
    <updated>2017-03-17T14:22:35.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PIL"><a href="#PIL" class="headerlink" title="PIL"></a>PIL</h1><p>PIL的全称为Python Imaging Library, 是Python中的一个免费的图像处理模块。</p><h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><p><code>from PIL import Image</code></p><h2 id="图片读取"><a href="#图片读取" class="headerlink" title="图片读取"></a>图片读取</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">img = Image.open(<span class="string">'000001.jpg'</span>) <span class="comment"># 返回一个Image图像对象</span></span><br><span class="line"><span class="keyword">print</span> img</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">&lt;PIL.JpegImagePlugin.JpegImageFile image mode=RGB size=<span class="number">353</span>x500 at <span class="number">0x2945A90</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="图像显示"><a href="#图像显示" class="headerlink" title="图像显示"></a>图像显示</h2><h3 id="导入包-1"><a href="#导入包-1" class="headerlink" title="导入包"></a>导入包</h3><p><code>import matplotlib.pyplot as plt</code></p><p>代码段：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>)) <span class="comment">#定义一个12*12 大小的画板</span></span><br><span class="line">ax.imshow(img) <span class="comment">#显示图片，此时图片还在内存中</span></span><br><span class="line">plt.axis(<span class="string">'off'</span>) <span class="comment">#消除横纵坐标</span></span><br><span class="line">ax.set_title(<span class="string">'000001.jpg'</span>)<span class="comment">#设置一个标题</span></span><br><span class="line">plt.show()<span class="comment">#显示图片，要不然没有办法显示</span></span><br></pre></td></tr></table></figure><h3 id="图片显示结果"><a href="#图片显示结果" class="headerlink" title="图片显示结果"></a>图片显示结果</h3><p><img src="/2017/03/17/python-PIL-matplotlib/图片显示.png" alt="图片显示"></p><h2 id="图片保存"><a href="#图片保存" class="headerlink" title="图片保存"></a>图片保存</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = Image.open(<span class="string">'000001.jpg'</span>) <span class="comment"># 返回一个Image图像对象</span></span><br><span class="line">img_save = img.save(<span class="string">'000001_save.png'</span>)<span class="comment">#保存图片并且同时改变图片的格式</span></span><br></pre></td></tr></table></figure><h2 id="图片转化为灰度图"><a href="#图片转化为灰度图" class="headerlink" title="图片转化为灰度图"></a>图片转化为灰度图</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img_save = img.save(<span class="string">'000001_save.png'</span>)</span><br><span class="line">img_gray = img.convert(<span class="string">"L"</span>)</span><br><span class="line"><span class="keyword">print</span> img_gray</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">&lt;PIL.Image.Image image mode=L size=<span class="number">353</span>x500 at <span class="number">0x264F780</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="灰度图片显示"><a href="#灰度图片显示" class="headerlink" title="灰度图片显示"></a>灰度图片显示</h3><p><img src="/2017/03/17/python-PIL-matplotlib/灰度图.png" alt="灰度图片"></p><h2 id="Image对象和图像矩阵之间转换"><a href="#Image对象和图像矩阵之间转换" class="headerlink" title="Image对象和图像矩阵之间转换"></a>Image对象和图像矩阵之间转换</h2><h3 id="导入包-2"><a href="#导入包-2" class="headerlink" title="导入包"></a>导入包</h3><p><code>import numpy as np</code></p><h3 id="Image对象转化成图像矩阵"><a href="#Image对象转化成图像矩阵" class="headerlink" title="Image对象转化成图像矩阵"></a>Image对象转化成图像矩阵</h3><p>Image对象转化成图像矩阵只要将Image对象作为<code>numpy.array()</code>参数即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img_array = np.array(img)</span><br><span class="line"><span class="keyword">print</span> img_array</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">[[[  <span class="number">1</span>   <span class="number">1</span>   <span class="number">0</span>]</span><br><span class="line">  [  <span class="number">1</span>   <span class="number">1</span>   <span class="number">0</span>]</span><br><span class="line">  [  <span class="number">1</span>   <span class="number">1</span>   <span class="number">0</span>]</span><br><span class="line"> <span class="comment">#忽略</span></span><br><span class="line">  [ <span class="number">31</span>  <span class="number">60</span> <span class="number">116</span>]</span><br><span class="line">  [ <span class="number">32</span>  <span class="number">58</span> <span class="number">119</span>]</span><br><span class="line">  [ <span class="number">26</span>  <span class="number">50</span> <span class="number">120</span>]]]</span><br></pre></td></tr></table></figure><h3 id="图像矩阵转化为Image对象"><a href="#图像矩阵转化为Image对象" class="headerlink" title="图像矩阵转化为Image对象"></a>图像矩阵转化为Image对象</h3><p>图像矩阵转化成Image对象通过<code>Image</code>模块的<code>fromarray()</code>方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = Image.open(<span class="string">'000001.jpg'</span>) <span class="comment"># 返回一个Image图像对象</span></span><br><span class="line">img_array = np.array(img)</span><br><span class="line"></span><br><span class="line">img_array = <span class="number">255</span> - img_array</span><br><span class="line">img_neg = Image.fromarray(img_array)</span><br></pre></td></tr></table></figure><p><img src="/2017/03/17/python-PIL-matplotlib/反向图.png" alt="将矩阵转化为Image对象"></p><h2 id="创建缩略图"><a href="#创建缩略图" class="headerlink" title="创建缩略图"></a>创建缩略图</h2><p>创建图像缩略图可以通过Image的<code>thumbnail()</code>方法，参数传入一个元组，指明缩略图的大小，如<code>thumbnail((128,128))</code></p><h2 id="图片截取"><a href="#图片截取" class="headerlink" title="图片截取"></a>图片截取</h2><p>截取图像中的一部分，并将这一部分作为一个新的Image对象。<br>截取区域的方法为<code>crop()</code>，参数为一个含4个元素的元组，用来指定截取区域的<strong>左上角点和右下角点</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = Image.open(<span class="string">'000001.jpg'</span>) <span class="comment"># 返回一个Image图像对象</span></span><br><span class="line"></span><br><span class="line">box = (<span class="number">48</span>,<span class="number">240</span>,<span class="number">196</span>,<span class="number">372</span>)</span><br><span class="line">img_crop = img.crop(box)</span><br></pre></td></tr></table></figure><p><img src="/2017/03/17/python-PIL-matplotlib/截取图.png" alt="image_crop"></p><h2 id="图像的尺寸调整和旋转"><a href="#图像的尺寸调整和旋转" class="headerlink" title="图像的尺寸调整和旋转"></a>图像的尺寸调整和旋转</h2><p>尺寸调整方法为<code>resize()</code>，参数为一元组，指定调整后的大小，如<code>resize((128,128))。 图像旋转的方法为</code>rotate()<code>，参数为旋转角度（数值，单位为度）,逆时针方向，如</code>rotate(45)`</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = Image.open(<span class="string">'000001.jpg'</span>) <span class="comment"># 返回一个Image图像对象</span></span><br><span class="line"></span><br><span class="line">image_resize = img.resize((<span class="number">200</span>,<span class="number">200</span>))</span><br><span class="line">image_rotate = img.rotate(<span class="number">45</span>)</span><br><span class="line"></span><br><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">1</span>,<span class="number">2</span>,figsize=(<span class="number">8</span>, <span class="number">8</span>)) <span class="comment">#定义一个12*12 大小的画板</span></span><br><span class="line"><span class="comment">#显示第一幅图片</span></span><br><span class="line">ax1.imshow(image_resize)</span><br><span class="line">ax1.axis(<span class="string">'off'</span>) <span class="comment">#消除横纵坐标</span></span><br><span class="line">ax1.set_title(<span class="string">'image_resize'</span>)<span class="comment">#设置一个标题</span></span><br><span class="line"><span class="comment">#显示第二幅图片</span></span><br><span class="line">ax2.imshow(image_rotate)</span><br><span class="line">ax2.axis(<span class="string">'off'</span>) <span class="comment">#消除横纵坐标</span></span><br><span class="line">ax2.set_title(<span class="string">'image_resize'</span>)<span class="comment">#设置一个标题</span></span><br><span class="line"></span><br><span class="line">plt.show()<span class="comment">#显示图片，要不然没有办法显示</span></span><br></pre></td></tr></table></figure><p><img src="/2017/03/17/python-PIL-matplotlib/resize_rotated.png" alt="resize and rotate"></p><h2 id="图像直方图"><a href="#图像直方图" class="headerlink" title="图像直方图"></a>图像直方图</h2><p>图像直方图用来统计图像中像素值的分布情况，即统计不同像素值出现的次数。方法为调用<code>matplotlib.pyplot</code>的<code>hist</code>方法，参数传入图像像素序列和统计区间个数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.cm <span class="keyword">as</span> cm</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读入图片并转化为灰度图</span></span><br><span class="line">img = Image.open(<span class="string">'000001.jpg'</span>).convert(<span class="string">"L"</span>)</span><br><span class="line">image_array = np.array(img)</span><br><span class="line"><span class="comment">#画图</span></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">plt.imshow(img,cmap=cm.gray)</span><br><span class="line">plt.axis(<span class="string">"off"</span>)</span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">plt.hist(image_array.flatten(), <span class="number">256</span>) <span class="comment">#flatten 可以将矩阵转化为一维序列</span></span><br><span class="line"></span><br><span class="line">plt.show()<span class="comment">#显示图片，要不然没有办法显示</span></span><br></pre></td></tr></table></figure><p><img src="/2017/03/17/python-PIL-matplotlib/img_hist.png" alt="img_hist"></p><h2 id="图像灰度变换"><a href="#图像灰度变换" class="headerlink" title="图像灰度变换"></a>图像灰度变换</h2><p>对于一张灰度图像，其每个像素点都用一个0-255之间的值表示，0表示黑色，越接近0越黑；255表示白色，越接近255越白。<br>灰度变换就是通过一个特定的函数，使灰度值从一个值转换成另外一个值。<br>这里列出3种灰度变换</p><ol><li><p>【反相】变换后的灰度值= 255−原灰度值</p></li><li><p>【转换到100-200】变换后的灰度值 =(原灰度值/255)*100+100</p></li><li><p>【像素平方】变换后的灰度值 = 255*(原灰度值/255)2</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.cm <span class="keyword">as</span> cm</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读入图片并转化为灰度图</span></span><br><span class="line">img = Image.open(<span class="string">'000001.jpg'</span>).convert(<span class="string">"L"</span>)</span><br><span class="line">image_array = np.array(img)</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">255</span>)</span><br><span class="line"><span class="comment">#画图</span></span><br><span class="line"><span class="comment"># 反相</span></span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plt.plot(x,<span class="number">255</span>-x) <span class="comment"># 画出变换函数图像</span></span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plt.imshow(Image.fromarray(<span class="number">255</span>-image_array),cmap=cm.gray)</span><br><span class="line">plt.axis(<span class="string">"off"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换到 100-200</span></span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">plt.plot(x,(x/<span class="number">255.0</span>)*<span class="number">100</span>+<span class="number">100</span>) <span class="comment"># 画出变换函数图像</span></span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">plt.imshow( Image.fromarray((image_array/<span class="number">255.0</span>)*<span class="number">100</span>+<span class="number">100</span>), cmap=cm.gray )</span><br><span class="line">plt.axis(<span class="string">"off"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 像素平方</span></span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line">plt.plot(x,<span class="number">255</span>*(x/<span class="number">255.0</span>)**<span class="number">2</span>) <span class="comment"># 画出变换函数图像</span></span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line">plt.imshow( Image.fromarray(<span class="number">255</span>*(image_array/<span class="number">255.0</span>)**<span class="number">2</span>), cmap=cm.gray )</span><br><span class="line">plt.axis(<span class="string">"off"</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li></ol><p><img src="/2017/03/17/python-PIL-matplotlib/gray_change.png" alt="gray_changed"></p><h2 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h2><p>由上面图像的直方图可以看出，一般情况下，图像上某些灰度值较多，有些灰度值较少，直方图均衡化为的是使灰度值较为均衡。</p><p>直方图均衡化是利用直方图的累积函数作为灰度变换函数，对图像进行转换。直方图均衡化可以增强图像的对比度。</p><p>累积函数和概率论中的累积分布函数类似。例如对于还有5个数的序列[1,2,3,4,5],其累积函数含有5个数，第一个数是1，第二个是1+2=3，……，第五个数是1+2+3+4+5=15，所以其累积函数是[1,3,6,10,15]。</p><p>我们把直方图均衡化的过程封装在一个函数里面，函数名字叫做histeq，输入原图像矩阵和直方图分块数，输出均衡化后的图像矩阵和累积函数。<img src="/2017/03/17/python-PIL-matplotlib/" alt=""></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.cm <span class="keyword">as</span> cm</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">histeq</span><span class="params">(image_array, image_bins=<span class="number">256</span>)</span>:</span></span><br><span class="line">    <span class="comment"># 将图像矩阵转化成直方图数据，返回元组(频数，直方图区间坐标)</span></span><br><span class="line">    image_array2, bins = np.histogram(image_array.flatten(), image_bins)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算直方图的累积函数</span></span><br><span class="line">    cdf = image_array2.cumsum()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将累积函数转化到区间[0,255]</span></span><br><span class="line">    cdf = (<span class="number">255.0</span> / cdf[<span class="number">-1</span>]) * cdf</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 原图像矩阵利用累积函数进行转化，插值过程</span></span><br><span class="line">    image2_array = np.interp(image_array.flatten(), bins[:<span class="number">-1</span>], cdf)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回均衡化后的图像矩阵和累积函数</span></span><br><span class="line">    <span class="keyword">return</span> image2_array.reshape(image_array.shape), cdf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读入图片并转化为灰度图</span></span><br><span class="line">img = Image.open(<span class="string">'000001.jpg'</span>).convert(<span class="string">"L"</span>)</span><br><span class="line">image_array = np.array(img)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plt.hist(image_array.flatten(),<span class="number">256</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plt.imshow(img,cmap=cm.gray)</span><br><span class="line">plt.axis(<span class="string">"off"</span>)</span><br><span class="line"></span><br><span class="line">a = histeq(image_array)  <span class="comment"># 利用刚定义的直方图均衡化函数对图像进行均衡化处理</span></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">plt.hist(a[<span class="number">0</span>].flatten(),<span class="number">256</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">plt.imshow(Image.fromarray(a[<span class="number">0</span>]),cmap=cm.gray)</span><br><span class="line">plt.axis(<span class="string">"off"</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2017/03/17/python-PIL-matplotlib/hist_norm.png" alt="直方图均衡"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PIL&quot;&gt;&lt;a href=&quot;#PIL&quot; class=&quot;headerlink&quot; title=&quot;PIL&quot;&gt;&lt;/a&gt;PIL&lt;/h1&gt;&lt;p&gt;PIL的全称为Python Imaging Library, 是Python中的一个免费的图像处理模块。&lt;/p&gt;
&lt;h3 id=&quot;导
      
    
    </summary>
    
    
      <category term="python, PIL, matplotlib" scheme="http://yoursite.com/tag/python-PIL-matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>python_parse_VOCxml_and_show</title>
    <link href="http://yoursite.com/2017/03/15/python-parse-VOCxml-and-show/"/>
    <id>http://yoursite.com/2017/03/15/python-parse-VOCxml-and-show/</id>
    <published>2017-03-15T08:48:22.000Z</published>
    <updated>2017-03-15T11:19:29.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天详细的处理了 一下VOC的XML 文件，包括将xml 解析出来，并将bbox显示出来。</p><h1 id="简要介绍一下VOC的xml文件"><a href="#简要介绍一下VOC的xml文件" class="headerlink" title="简要介绍一下VOC的xml文件"></a>简要介绍一下VOC的xml文件</h1><p>VOC的检测任务的目标标签是写在对应xml文件中的。一般xml文件会包含对应图片的名字，尺寸，以及难度，以及所有目标的名字，和boundingbox的对角坐标。</p><p>下面给出一个xml的示例：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">annotation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">folder</span>&gt;</span>VOC2007<span class="tag">&lt;/<span class="name">folder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filename</span>&gt;</span>000001.jpg<span class="tag">&lt;/<span class="name">filename</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">database</span>&gt;</span>The VOC2007 Database<span class="tag">&lt;/<span class="name">database</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">annotation</span>&gt;</span>PASCAL VOC2007<span class="tag">&lt;/<span class="name">annotation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">image</span>&gt;</span>flickr<span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">flickrid</span>&gt;</span>341012865<span class="tag">&lt;/<span class="name">flickrid</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">owner</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">flickrid</span>&gt;</span>Fried Camels<span class="tag">&lt;/<span class="name">flickrid</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Jinky the Fruit Bat<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">owner</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">size</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">width</span>&gt;</span>353<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">height</span>&gt;</span>500<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">depth</span>&gt;</span>3<span class="tag">&lt;/<span class="name">depth</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">size</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">segmented</span>&gt;</span>0<span class="tag">&lt;/<span class="name">segmented</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dog<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pose</span>&gt;</span>Left<span class="tag">&lt;/<span class="name">pose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">truncated</span>&gt;</span>1<span class="tag">&lt;/<span class="name">truncated</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">difficult</span>&gt;</span>0<span class="tag">&lt;/<span class="name">difficult</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bndbox</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xmin</span>&gt;</span>48<span class="tag">&lt;/<span class="name">xmin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ymin</span>&gt;</span>240<span class="tag">&lt;/<span class="name">ymin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xmax</span>&gt;</span>195<span class="tag">&lt;/<span class="name">xmax</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ymax</span>&gt;</span>371<span class="tag">&lt;/<span class="name">ymax</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bndbox</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>person<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pose</span>&gt;</span>Left<span class="tag">&lt;/<span class="name">pose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">truncated</span>&gt;</span>1<span class="tag">&lt;/<span class="name">truncated</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">difficult</span>&gt;</span>0<span class="tag">&lt;/<span class="name">difficult</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bndbox</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xmin</span>&gt;</span>8<span class="tag">&lt;/<span class="name">xmin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ymin</span>&gt;</span>12<span class="tag">&lt;/<span class="name">ymin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xmax</span>&gt;</span>352<span class="tag">&lt;/<span class="name">xmax</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ymax</span>&gt;</span>498<span class="tag">&lt;/<span class="name">ymax</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bndbox</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">annotation</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的图片是：</p><p><img src="/2017/03/15/python-parse-VOCxml-and-show/000001.jpg" alt="000001.jpg"></p><h1 id="python解析XML文件"><a href="#python解析XML文件" class="headerlink" title="python解析XML文件"></a>python解析XML文件</h1><h2 id="导入xml包"><a href="#导入xml包" class="headerlink" title="导入xml包"></a>导入xml包</h2><p><code>import xml.etree.ElementTree as ET</code></p><p><strong>直接贴代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_rec</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">"""parse a pascal voc xml file"""</span></span><br><span class="line">    tree = ET.parse(filename) <span class="comment"># </span></span><br><span class="line">    objects = []</span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> tree.findall(<span class="string">'object'</span>):</span><br><span class="line">        obj_struct = &#123;&#125;</span><br><span class="line">        obj_struct[<span class="string">'name'</span>] = obj.find(<span class="string">'name'</span>).text</span><br><span class="line">        obj_struct[<span class="string">'pose'</span>] = obj.find(<span class="string">'pose'</span>).text</span><br><span class="line">        obj_struct[<span class="string">'truncated'</span>] = int(obj.find(<span class="string">'truncated'</span>).text)</span><br><span class="line">        obj_struct[<span class="string">'difficult'</span>] = int(obj.find(<span class="string">'difficult'</span>).text)</span><br><span class="line">        bbox = obj.find(<span class="string">'bndbox'</span>)</span><br><span class="line">        obj_struct[<span class="string">'bbox'</span>] = [int(bbox.find(<span class="string">'xmin'</span>).text),</span><br><span class="line">                              int(bbox.find(<span class="string">'ymin'</span>).text),</span><br><span class="line">                              int(bbox.find(<span class="string">'xmax'</span>).text),</span><br><span class="line">                              int(bbox.find(<span class="string">'ymax'</span>).text)]</span><br><span class="line">        objects.append(obj_struct)</span><br><span class="line">    <span class="keyword">return</span> objects</span><br></pre></td></tr></table></figure><p>如此得到的结果是一个list, list中的元素就是每一个object, 可以看到object每一个都是一个dict(键值对)：</p><p><code>[{&#39;difficult&#39;: 0, &#39;pose&#39;: &#39;Left&#39;, &#39;name&#39;: &#39;dog&#39;, &#39;bbox&#39;: [48, 240, 195, 371], &#39;truncated&#39;: 1}, {&#39;difficult&#39;: 0, &#39;pose&#39;: &#39;Left&#39;, &#39;name&#39;: &#39;person&#39;, &#39;bbox&#39;: [8, 12, 352, 498], &#39;truncated&#39;: 1}]</code></p><h1 id="python显示xml结果"><a href="#python显示xml结果" class="headerlink" title="python显示xml结果"></a>python显示xml结果</h1><h2 id="导入matplotlib和PIL包"><a href="#导入matplotlib和PIL包" class="headerlink" title="导入matplotlib和PIL包"></a>导入matplotlib和PIL包</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><p><strong>直接贴代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">image = Image.open(<span class="string">'000001.jpg'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">12</span>, <span class="number">12</span>))</span><br><span class="line">ax.imshow(image, aspect=<span class="string">'equal'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(object)):</span><br><span class="line">    bbox = object[i][<span class="string">'bbox'</span>]</span><br><span class="line">    name = object[i][<span class="string">'name'</span>]</span><br><span class="line">    ax.add_patch(</span><br><span class="line">        plt.Rectangle((bbox[<span class="number">0</span>], bbox[<span class="number">1</span>]),</span><br><span class="line">                        bbox[<span class="number">2</span>] - bbox[<span class="number">0</span>],</span><br><span class="line">                        bbox[<span class="number">3</span>] - bbox[<span class="number">1</span>], fill=<span class="keyword">False</span>,</span><br><span class="line">                      edgecolor=<span class="string">'red'</span>, linewidth=<span class="number">3.5</span></span><br><span class="line">        )</span><br><span class="line">    )<span class="comment">#画矩形</span></span><br><span class="line">    ax.text(bbox[<span class="number">0</span>], bbox[<span class="number">1</span>] - <span class="number">2</span>,</span><br><span class="line">            <span class="string">'&#123;:s&#125;'</span>.format(name),</span><br><span class="line">            bbox=dict(facecolor=<span class="string">'blue'</span>, alpha=<span class="number">0.5</span>),</span><br><span class="line">            fontsize=<span class="number">14</span>, color=<span class="string">'white'</span>)<span class="comment">#矩形框的标签</span></span><br><span class="line"></span><br><span class="line">ax.set_title(<span class="string">'parse image '</span>)</span><br><span class="line">plt.axis(<span class="string">"off"</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>结果图：</p><p><img src="/2017/03/15/python-parse-VOCxml-and-show/result_parse_vocxml.png" alt="000001.jpg"></p><h1 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天详细的处理了 一下VOC的XML 文件，包括将xml 解析出来，并将bbox显示出来。&lt;/p&gt;
&lt;h1 id=&quot;简要介绍一下VOC的xm
      
    
    </summary>
    
    
      <category term="python VOCxml" scheme="http://yoursite.com/tag/python-VOCxml/"/>
    
  </entry>
  
  <entry>
    <title>Written Memories:Understanding,Deriving and Extending the LSTM</title>
    <link href="http://yoursite.com/2016/08/25/Written-LSTM/"/>
    <id>http://yoursite.com/2016/08/25/Written-LSTM/</id>
    <published>2016-08-25T02:34:17.000Z</published>
    <updated>2017-03-20T02:07:47.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p><strong>动机：</strong>锻炼一下自己的英文能力，同时加深对LSTM的理解。</p><p>   本文是对<a href="http://r2rt.com/written-memories-understanding-deriving-and-extending-the-lstm.html" target="_blank" rel="noopener">Written Memories: Understanding, Deriving and Extending the LSTM</a>的翻译。</p><p><strong>有什么错误请指正！</strong></p><p>   当我第一次接触 Long Short-Term Memory networks(LSTM)时，我很难理解它的复杂性。我甚至不理解为什么它以这种方式设计就可以产生很好地 效果。后来，我发现LSTM是可以被理解的。尽管它表面看起来很复杂。LSTM实际上是基于一系列十分简单，甚至优美的对于神经网络的一些深刻思考。我真希望这篇博客是我第一次学习循环神经网络。</p><p> <strong>在这篇博文中，我们将做如下几件事情：</strong></p><ol><li><p>我们将定义recurrent neural networks(RNNs)，我们将关注于RNNs的局限性，从而导致了LSTM的发展。</p></li><li><p>我们将介绍LSTM结构背后的直觉。然后我们以此为依据拓展LSTM。沿着这个思路，我们将派生出GRU。我们将推导出伪LSTM。而这种LSTM将比传统的LSTM的性能更好。</p></li><li><p>接下来我们将推广这些直觉的知识是怎么在最近的优秀的结构中得到运用的。比如（highway，残差网络，神经图灵机）。</p><p>本文是关于理论知识的，并没有实现的内容，至于使用Tensorflow实现RNNs可以参考如下的博客。<br><a href="http://r2rt.com/recurrent-neural-networks-in-tensorflow-i.html" target="_blank" rel="noopener"> Recurrent Neural Networks in Tensorflow I</a>和<a href="http://r2rt.com/recurrent-neural-networks-in-tensorflow-ii.html" target="_blank" rel="noopener">Recurrent Neural Networks in Tensorflow II</a>。</p></li></ol><h1 id="内容-快速链接："><a href="#内容-快速链接：" class="headerlink" title="内容/快速链接："></a>内容/快速链接：</h1><ul><li>递归神经网络</li><li>RNNs可以做什么？选择单位时间</li><li>主流的RNNs</li><li>信息变形，弥散，和爆炸敏感性</li><li>针对信息弥散的充要条件</li><li>沿着时间轴的后向传播和梯度弥散敏感度</li><li>解决梯度弥散和梯度爆炸问题</li><li>LSTMs背后的直觉知识：保存记忆</li><li>使用选择性的控制和协调</li><li>选择的机制：Gates</li><li>将Gates粘合在一起派生出了LSTM原型</li><li>三个模型：归一化原型，GRU, 以及伪LSTM</li><li>推导LSTM</li><li>有窥视孔的LSTM</li><li>基本的LSTM与伪LSTM的经验性比较</li><li>拓展LSTM</li></ul><h1 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h1><h6 id=""><a href="#" class="headerlink" title=" "></a> </h6><p>​    本篇文章假设读者已将熟悉了：</p><ol><li><p>前向神经网络</p></li><li><p>反向传播</p></li><li><p>基本的线性代数</p><p>   我们也将回顾一些其他的知识，让我们从RNNs开始吧。</p></li></ol><h1 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h1><p>​    </p><p>​    从一个时刻到下一个时刻，我们的大脑就像一个函数一样在工作，它从我们的感官（外部）和我们的思维（内部）得到输入，然后处理一番，得到以动作形式（外部）和新的想法（内部）的输出。例如，我们看到 一只熊，然后我们就会想到单词“熊”，我们可以构建一个神经网络来模拟这种行为，我们可以训练神经网络去联想到单词“熊”当它看到一张熊的照片的时候。但是我们的大脑不仅仅是一个只有一次的函数，它随着时间重复运行。我们看见一只熊，然后我们想到了单词“熊”,然后我们就会想到“跑”， 重要的是，将熊的图片转化为单词“熊的网络和将单词“熊”转化为”跑“的网络是十分相似的。同时，它也是一个 循环的函数，对于这样的函数我们可以用递归神经网络来模拟。</p><p>​    RNN网络是一系列完全相同的前向神经网络的组合，每一个前向神经网络处理每一个时间步，我们都称之为“RNN cells”.值得注意的是这个定义比我们通常的对RNN的定义(“vanilla” RNN将在下文中介绍作为LSTM的先驱)更为广泛。这些cells可以处理他们自己的输出，允许他们(cells)被组合。他们同时可以处理外部的输入，产生外部的输出。下面是单独一个RNN cell 的示例图：</p><p><img src="/2016/08/25/Written-LSTM/NH_SingleRNNcell.png" alt="Single_RNN_cell"></p><p>下面是三个RNN cell的组合的示例图：</p><p><img src="/2016/08/25/Written-LSTM/NH_ComposedRNNcells.png" alt="NH_Composed_RNN_cells"></p><p>​    你可以认为这种循环的输出是“状态”，他们被输入到下一个时间步。所以，一个“RNN cell” 接收前一个状态和现有的输入(可选)，然后输出现在的状态，以及现在的输出(可选)。</p><p>下面是“RNN cell” 的代数描述:<br>$$<br>\binom{s<em>{t}}{o</em>{t}} = f\binom{s<em>{t-1}}{x</em>{t}}<br>$$<br>其中：<br>$$<br>s<em>{t}和s</em>{t-1}表示当前和前一刻状态<br>$$</p><p>$$<br>o_{t}表示当前时刻的输出(可能是空)<br>$$</p><p>$$<br>x_{t}是当前状态的输入,f是当前的循环函数<br>$$</p><p>​    我们就大脑的运行方式：当前的神经元活动将会替代之前的神经元活动。我们可以将RNNs看做这种原地的操作，因为”RNN cell”是完全相同的，他们可以被看做是相同的对象，只是在每一个时间步他们的状态会被覆盖。下面是这个框架的示例图：</p><p><img src="/2016/08/25/Written-LSTM/NH_StateLoop.png" alt="NH_State_Loop"></p><p>​    大多数对于RNNs的介绍都是从”single cell loop”框架开始的，但是我认为读者应该会认为以上连续的框架会更加的直观，特别是考虑到反向传播的时候。当我们从”single cell loop”开始学习的额时候。RNN会被引入”unrolled”以得到上面所提到的连续的框架。</p><h1 id="RNNs可以做什么？选择单位时间"><a href="#RNNs可以做什么？选择单位时间" class="headerlink" title="RNNs可以做什么？选择单位时间"></a>RNNs可以做什么？选择单位时间</h1><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;动机：&lt;/strong&gt;锻炼一下自己的英文能力，同时加深对LSTM的理解。&lt;/p&gt;
&lt;p&gt; 
      
    
    </summary>
    
    
      <category term="LSTM" scheme="http://yoursite.com/tag/LSTM/"/>
    
  </entry>
  
  <entry>
    <title>CUDA安装教程</title>
    <link href="http://yoursite.com/2016/08/22/CUDA_installration/"/>
    <id>http://yoursite.com/2016/08/22/CUDA_installration/</id>
    <published>2016-08-22T10:28:02.000Z</published>
    <updated>2017-03-22T06:08:17.502Z</updated>
    
    <content type="html"><![CDATA[<p><strong>动机</strong>：重新整理一下CUDA的安装过程(虽然已经安装过很多次了)。</p><p><strong>环境</strong>： Ubuntu14.04， Titanx 显卡. </p><p><strong>待安装</strong>： <a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="noopener">CUDA7.5</a>， <a href="https://developer.nvidia.com/rdp/cudnn-download#a-collapseOne" target="_blank" rel="noopener">cuDNN v5.1</a>(下载这个，你得先注册了。注册然后等一天，才有资格下载。).</p><p><a href="http://baike.baidu.com/link?url=etasXojff5VuHUkZFMvWztQXAlPxJjJrPSt0qsOH1NAmMi5quvZFnCgaEfJYbFQH8IiWUi8aox5Mw_yg-y6Htq" target="_blank" rel="noopener"><strong>简介</strong></a>: CUDA(Compute Unified Device Architecture)，是显卡厂商NVIDIA推出的运算平台。 CUDA™是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。 它包含了CUDA指令集架构（ISA）以及GPU内部的并行计算引擎。 开发人员现在可以使用C语言来为CUDA™架构编写程序，C语言是应用最广泛的一种高级编程语言。所编写出的程序于是就可以在支持CUDA™的处理器上以超高性能运行。CUDA3.0已经开始支持C++和FORTRAN。</p><p><strong>Step1</strong>：<strong><em>下载所需的文件</em></strong></p><p>*首先从网站上下载<a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="noopener">CUDA</a> 和 <a href="https://developer.nvidia.com/rdp/cudnn-download#a-collapseOne" target="_blank" rel="noopener">cuDNN v5.1</a>。至于CUDA选择哪个版本的可以参考下图</p><p><img src="/2016/08/22/CUDA_installration/cuda7.5.jpg" alt="cuda7.5.jpg"></p><p><strong>Step2</strong>： <strong><em>安装CUDA</em></strong> </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i cuda-repo-ubuntu1404-7-5-local_7.5-18_amd64.deb</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install cuda</span><br></pre></td></tr></table></figure><p><strong>Step3</strong>： <strong><em>安装cuDNN</em></strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  tar -zxvf cudnn-7.5-linux-x64-v5.1.tgz </span><br><span class="line">  <span class="built_in">cd</span> cudnn-7.5-linux-x64-v5.1 </span><br><span class="line">  sudo cp lib* /usr/<span class="built_in">local</span>/cuda/lib64/  <span class="comment">## 这一步是在 lib文件夹下面</span></span><br><span class="line">  sudo cp cudnn.h /usr/<span class="built_in">local</span>/cuda/include/ </span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">更新软连接</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/cuda/lib64/  </span><br><span class="line">  sudo rm -rf libcudnn.so libcudnn.so.5  </span><br><span class="line">  sudo ln -s libcudnn.so.5.0.5 libcudnn.so.5.0  </span><br><span class="line">  sudo ln -s libcudnn.so.5.0 libcudnn.so</span><br></pre></td></tr></table></figure><p><strong>Step4</strong>：<strong><em>设置环境变量</em></strong></p><p>在/etc/profile中添加CUDA环境变量</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/profile</span><br></pre></td></tr></table></figure><p>内容如下:</p><blockquote><p>PATH=/usr/local/cuda-7.5/bin:$PATH<br>export PATH</p></blockquote><p>保存后, 执行下列命令, 使环境变量立即生效</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>同时需要添加lib库路径： 在 /etc/ld.so.conf.d/加入文件 cuda.conf, </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/ld.so.conf.d/cuda.conf</span><br></pre></td></tr></table></figure><p>内容如下:</p><blockquote><p>/usr/local/cuda-7.5/lib64</p></blockquote><p>保存后，执行下列命令使之立刻生效</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><p><strong>DONE !</strong><br>检验一下安装情况吧：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      简单总结一下CUDA的安装过程。
    
    </summary>
    
    
      <category term="CUDA" scheme="http://yoursite.com/tag/CUDA/"/>
    
  </entry>
  
  <entry>
    <title>2D_Convolution</title>
    <link href="http://yoursite.com/2016/08/18/2D-Convolution/"/>
    <id>http://yoursite.com/2016/08/18/2D-Convolution/</id>
    <published>2016-08-18T08:53:16.000Z</published>
    <updated>2018-09-10T05:28:06.283Z</updated>
    
    <content type="html"><![CDATA[<p>本文原地址:<a href="http://blog.sciencenet.cn/blog-268138-383185.html" target="_blank" rel="noopener">this page</a>  </p><p><strong>卷积运算</strong>(Convolution)是通过两个函数f 和g 生成第三个函数的一种数学算子，表示函数f 与经过翻转和平移与g 的重叠部分的累积。如果将参加卷积的一个函数看作区间的指示函数，卷积还可以被看作是“滑动平均”的推广。</p><p>假设: f(x),g(x)是R1上的两个可积函数，并且积分是存在的。这样，随着 x 的不同取值，这个积分就定义了一个新函数h(x)，称为函数f 与g 的卷积，记为h(x)＝(f*g)(x)。</p><p>两个向量卷积，说白了就是<strong>多项式乘法</strong>。下面用个矩阵例子说明其工作原理：</p><p><img src="/2016/08/18/2D-Convolution/2D_Convolution1.jpg" alt="2D_Convolution1"></p><p><img src="/2016/08/18/2D-Convolution/2D_Convolution2.jpg" alt="2D_Convolution2"></p><p>a和d的卷积就是，把a和d的第一行作为一个多项式的系数，按多项式升幂排列（也可以按降幂），即为：</p><p><img src="/2016/08/18/2D-Convolution/2D_Convolution3.jpg" alt="2D_Convolution3"></p><p>所得卷积矩阵为：</p><p><img src="/2016/08/18/2D-Convolution/2D_Convolution.jpg" alt="2D_Convolution"></p><p>这就是卷积运算的工作原理，在图像处理中用处非常大。</p>]]></content>
    
    <summary type="html">
    
      卷积和多项式乘法的联系
    
    </summary>
    
    
      <category term="卷积" scheme="http://yoursite.com/tag/%E5%8D%B7%E7%A7%AF/"/>
    
  </entry>
  
</feed>
