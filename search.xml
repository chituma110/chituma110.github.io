<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Caffe安装新坑]]></title>
    <url>%2F2017%2F12%2F06%2Fcaffe_install%2F</url>
    <content type="text"><![CDATA[#写在前面的话 今天教研室新进了两台双TITANX的机器。老板大人叫我测一下，机器跑网络的时候声音大不大。本来觉得简单得很，，，毕竟我已经是老手了。但是现实给了我一个小巴掌。。。啪啪作响。。 遇到三个问题。 问题一 更新源时出现 404 NotFound sudo apt-get update这句是常用的更新源的命令。但是嘞，这段时间出现了个怪现象， W: 无法下载 http://ppa.launchpad.net/fcitx-team/nightly/ubuntu/dists/jessie/main/binary-amd64/Packages 404 Not Found 出现了这个状况咋解决了？ #解决方案： 将对应的PPA删除掉即可 使用以下命令切换到对应PPA目录： cd /etc/apt/sources.list.d 找到上述无法下载的对应PPA目录，即extra-ppas.list，安全起见，用mv命令将该文件添加后缀.bak即可 这个时候就好了。 问题二 libopencv-dev的安装 安装opencv真的是个大坑。。。我先是用最基本的sudo apt-get install libopencv-dev来安装的。但是嘞，出现了个错误，就是说libatk无法安装。怎么弄都解决不了。 后来我安装了aptitude(sudo apt-get install aptitude) 然后利用aptitude 来安装libopencv-dev（sudo aptitude install libopencv-dev） 你还真别说。。。这么一变化，我还就安装成功了。。。。 问题三 libcudart.so.8.0这个问题最好解决。 `export LD_LIBRARY_PATH=/usr/local/cuda-8.0/lib64:$LD_LIBRARY_PATH export PATH=/usr/local/cuda-8.0/bin:$PATH` 你还别说，就这3个小问题。。。折腾了我一个下午。。。主要是如何解决问题二。]]></content>
      <tags>
        <tag>opencv, libatk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_file_print]]></title>
    <url>%2F2017%2F05%2F07%2Fpython-file-print%2F</url>
    <content type="text"><![CDATA[写在前面的话​ 最近在重新翻看《Python核心编程(第二版)》，发现之前忽略的一个知识点，就是文件的输出中关于换行符(‘\n’)的处理。于是就想写在这里做个记录。 背景大概就是我有一个txt文件，这个时候我要把它的每一行都打印出来，但是我们知道文本的每一行都有一个’\n’换行符。。这就麻烦了。。我们直接上个代码来看看。。 文件 正常的文件读取是什么样的呢？直接上代码： file = open('index_display.txt')for eachLine in file: print eachLinefile.close() 结果呢： 我们可以看到，每两行输出之间都会有一个空行，，这样就太不美观了。也和原始图片不相符。。那么我们怎么修改呢？狠狠简单。 狠狠简单，，，简单的你都想不到。。。file = open('index_display.txt')foe eachLine in file: print eachLine,file.close() 這時候的結果呢？ 發現沒有啊？我們僅僅是加了一個小小的逗號。。。哈哈哈就可以完美的解決這個問題了。 解释print语句默认在输出内容末尾后加一个换行符，而在语句后加一个逗号就可以避免这个行为。readline()和readlines()函数不对行里面的空白字符做任何处理，所以我们有必要加上逗号，如果我们省略逗号，那么显示出的文本每行后会有两个换行符，其中一个是输入是附带的，另一个是print语句自动添加。 参考《Python核心编程(第二版)》]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Caffe_solver小结]]></title>
    <url>%2F2017%2F03%2F28%2Fcaffe-solver%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[python之于LMDB初探]]></title>
    <url>%2F2017%2F03%2F28%2Fpython%E4%B9%8B%E4%BA%8ELMDB%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[写在前面的话这几天做老板的项目，因为大家的数据集简直脏的要我命，我将数据按照SSD的creat_data.sh的方式做成LMDB，然后在处理的时候每次到达一定的迭代次数，就会出现img_channel为1。但是mean_value的channel是3.这就尴尬了啊。。。我完全不知道是哪张图片，而且可想而知，有一张就不可能仅仅就只有一张。。。所以我就想办法处理掉这些错误的图片。于是在处理这个错误的时候我就想将LMDB中数据给一一读出来。于是就有了下面的内容。 直接放代码 import syssys.path.insert(0, "/home/caffe-master/python")#将caffepython的加入python路径中，0：是放在PYTHONPATH中的位置,后面就是caffepython的路径。import caffe#上面一句话就是为了这一句不出错import numpy as npimport lmdbimport argparse#做输入的if __name__ == '__main__': parse = argparse.ArgumentParser()#创建命令行对象 paese.add_argument('--lmdbpath')#添加一个命令 args = parse.parse_args()#解析命令行 env = lmdb.open(args.lmdbpath, readonly=True)#打开LMDB文件，只读。 with env.begin() as txn: cursor = txn.cursor() #A for key, value in cursor: #print(key, len(value))#value是string类型 print 'key: ',key datum = caffe.proto.caffe_pb2.Datum()#datum类型 #B datum.ParseFromString(value)#转化为datum flat_x = np.fromstring(datum.data, dtype=np.uint8)#转化为numpy类型 #C 结果： #.................前面有30571个这样的输出.........................key: 00030572_new_data/JPEGImage/IMG_LIANGXJ_028_2.jpg 解释： 下面给出A, B, C 三处的对象所对应的方法： print dir(cursor)['__class__', '__delattr__', '__doc__', '__enter__', '__exit__', '__format__', '__getattribute__', '__hash__', '__init__', '__iter__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '_iter_from', 'close', 'count', 'delete', 'first', 'first_dup', 'get', 'item', 'iternext', 'iternext_dup', 'iternext_nodup', 'iterprev', 'iterprev_dup', 'iterprev_nodup', 'key', 'last', 'last_dup', 'next', 'next_dup', 'next_nodup', 'pop', 'prev', 'prev_dup', 'prev_nodup', 'put', 'putmulti', 'replace', 'set_key', 'set_key_dup', 'set_range', 'set_range_dup', 'value'] print dir(datum)['ByteSize', 'CHANNELS_FIELD_NUMBER', 'Clear', 'ClearExtension', 'ClearField', 'CopyFrom', 'DATA_FIELD_NUMBER', 'DESCRIPTOR', 'DiscardUnknownFields', 'ENCODED_FIELD_NUMBER', 'FLOAT_DATA_FIELD_NUMBER', 'FindInitializationErrors', 'FromString', 'HEIGHT_FIELD_NUMBER', 'HasExtension', 'HasField', 'IsInitialized', 'LABEL_FIELD_NUMBER', 'ListFields', 'MergeFrom', 'MergeFromString', 'ParseFromString', 'RegisterExtension', 'SerializePartialToString', 'SerializeToString', 'SetInParent', 'WIDTH_FIELD_NUMBER', 'WhichOneof', '_InternalParse', '_InternalSerialize', '_Modified', '_SetListener', '_UpdateOneofState', '__class__', '__deepcopy__', '__delattr__', '__doc__', '__eq__', '__format__', '__getattribute__', '__getstate__', '__hash__', '__init__', '__metaclass__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setstate__', '__sizeof__', '__slots__', '__str__', '__subclasshook__', '__unicode__', '__weakref__', '_cached_byte_size', '_cached_byte_size_dirty', '_decoders_by_tag', '_extensions_by_name', '_extensions_by_number', '_fields', '_is_present_in_parent', '_listener', '_listener_for_children', '_oneofs', '_unknown_fields', 'channels', 'data', 'encoded', 'float_data', 'height', 'label', 'width'] print dir(flat_x)['T', '__abs__', '__add__', '__and__', '__array__', '__array_finalize__', '__array_interface__', '__array_prepare__', '__array_priority__', '__array_struct__', '__array_wrap__', '__class__', '__contains__', '__copy__', '__deepcopy__', '__delattr__', '__delitem__', '__delslice__', '__div__', '__divmod__', '__doc__', '__eq__', '__float__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getslice__', '__gt__', '__hash__', '__hex__', '__iadd__', '__iand__', '__idiv__', '__ifloordiv__', '__ilshift__', '__imod__', '__imul__', '__index__', '__init__', '__int__', '__invert__', '__ior__', '__ipow__', '__irshift__', '__isub__', '__iter__', '__itruediv__', '__ixor__', '__le__', '__len__', '__long__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__nonzero__', '__oct__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdiv__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__setitem__', '__setslice__', '__setstate__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__xor__', 'all', 'any', 'argmax', 'argmin', 'argpartition', 'argsort', 'astype', 'base', 'byteswap', 'choose', 'clip', 'compress', 'conj', 'conjugate', 'copy', 'ctypes', 'cumprod', 'cumsum', 'data', 'diagonal', 'dot', 'dtype', 'dump', 'dumps', 'fill', 'flags', 'flat', 'flatten', 'getfield', 'imag', 'item', 'itemset', 'itemsize', 'max', 'mean', 'min', 'nbytes', 'ndim', 'newbyteorder', 'nonzero', 'partition', 'prod', 'ptp', 'put', 'ravel', 'real', 'repeat', 'reshape', 'resize', 'round', 'searchsorted', 'setfield', 'setflags', 'shape', 'size', 'sort', 'squeeze', 'std', 'strides', 'sum', 'swapaxes', 'take', 'tobytes', 'tofile', 'tolist', 'tostring', 'trace', 'transpose', 'var', 'view'] 写在后面的话在这一次我只查看了datum的channels性质。但是后来我发现所有的datum的channels都是0(ssd在创建LMDB的时候有一个encode选项，，后来我查看了ImageNet的LMDB的channels确实是3).。。。。这就尴尬了。。。还是没有办法解决问题。后来我将batchsize调整为1，每迭代一次就打印出结果，，这样。。。找到了对应的错误图片，然后我将对应的人的所有图片全部删除了。现在搞定了。。。]]></content>
      <tags>
        <tag>Python, LMDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python写caffe层]]></title>
    <url>%2F2017%2F03%2F22%2FPython%E5%86%99caffe%E5%B1%82%2F</url>
    <content type="text"><![CDATA[写在前面的话因为工作需要，需要用Python写新层，正好也看过这方面的工作。今天就来小小的记录一下，以免自己忘记了。 Python写层最多的是看到些数据层。所以我们今天就写一个数据层的例子。我们一共分3步走。 步奏一：写新层​ #！-*- coding: utf-8 -*-#author = Cqs#FileName: MyPythonLayer.py #1import caffeimport yaml, globfrom random import shuffleimport cv2import logginglogging.basicConfig(level=logging.INFO)class myPythonLayer(caffe.Layer): """ reshape images """ def setup(self, bottom, top): params_str = self.param_str.split(',') params = [yaml.load(item) for item in params_str] #2 print params self.source = params[0]['source_dir'] self.target_size = params[1]['target_size'] self.batch_size = params[2]['batch_size']#3 self.batch_loader = BatchLoader(source_dir=self.source, target_size=self.target_size) print 'Parameter batch_size:&#123;&#125;\n' \ 'source_dir:&#123;&#125;\n' \ 'target_size:&#123;&#125;'.format(self.batch_size, self.source, self.target_size) top[0].reshape(self.batch_size, self.target_size, self.target_size, 3) def reshape(self, bottom, top): pass def forward(self, bottom, top): for i in xrange(self.batch_size): top[0].data[i, ...] = self.batch_loader.next_batch() def backward(self, bottom, propagate_down, top): passclass BatchLoader(object): def __init__(self, source_dir, target_size): self.cur = 0 self.target_size = target_size self.indexlist = glob.glob(source_dir+ '/*.jpg')#4 def next_batch(self): if self.cur == len(self.indexlist): self.cur = 0 shuffle(self.indexlist) item = self.indexlist[self.cur] img_tmp = cv2.imread(item) img_tmp = cv2.resize(src=img_tmp, dsize=(self.target_size, self.target_size)) self.cur += 1 logging.info('load &#123;&#125; images'.format(self.cur)) return img_tmp ​ 代码解释：#1 处是脚本的名字，这个名字在网络定义文件prototxt中会用到。 ​ #2 处的yaml的使用是解析str。str必须以空格间隔，比如”‘batch_size’: 50”, ‘batch_size’: 与50以空格间 隔，反之会报错，这里因为有多个,我不会解析多个对，因此提前将其split,分而治之。 ​ #3处的参数的顺序很重要，网络定义的prototxt的参数的顺序要根据这个来。 ​ #4处的glob.glob(source_dir+ ‘/*.jpg’)返回的是一个list,是source_dir文件夹下的所有jpg文件的绝对路径。 ​ 代码位置：一般我写的Python层都会放在caffe-master/Python/caffe文件夹下面。这样可以直接找到。 (有时候可能找不到你写的这个新的层，那么你可以添加如下代码：) import sys sys.path.append(‘存放模块的文件夹’) 上面这段代码的意思就是将该模块放到PATHONPATH中 ​ 代码格式： ​ class myPythonLayer(caffe.Layer): ​ def setup(self, bottom, top): ​ def reshape(self, bottom, top): ​ def forward(self, bottom, top): ​ def backward(self, bottom, propagate, top): 可以看到新层是继承caffe.Layer的，这是必须的。同时，大部分层包含四个方法，分别是setup, reshape, forward, backward.这四个函数。setup是对层的初始化过程,当层被调用的时候，会调用方法forward. top必须被reshape,否则在blob.cpp中的CHECK(data_)的报错。 forward应该是必须的。但是backward可以不是必须的。因为网络必须要有前向操作但是可以没有反向传播。 注意forward和backward 两个方法的参数 ​ 步骤二：生成prototxt本来可以用Python直接生成prototxt的。但是我这里遇到了带你问题，我这里还是直接给出prototxt吧。下次博客再给出Python代码生成prototxt的方法吧。 #file_name = mylayer.prototxtlayer&#123;name:'mylayer'type:'Python'top:'images'python_param&#123; module:'MyPythonLayer' layer:'myPythonLayer' param_str:"'source_dir': '/home/amax/cqs/caffe-master/example/Cqs/data','target_size': 100,'batch_size': 200"&#125;&#125; 解释： 我们用Python写的层的type都是’python’. pathon_param要给出模块的名字，也就是我们写的新层的文件的名字，而layer就是我们的新层的名字。这里要注意param_str的顺序。 步奏三：调用运行！#-*- coding: utf-8 -*-author = Cqsfrom future import print_functionimport caffeif __name__=='__main__': net = caffe.Net('mylayer.prototxt', caffe.TEST) net.forward() images = net.blobs['images'].data print(images.shape) 运行结果： /usr/bin/python2.7 /home/amax/cqs/caffe-master/examples/Cqs/test.pyWARNING: Logging before InitGoogleLogging() is written to STDERR[&#123;'source_dir': '/home/amax/cqs/caffe-master/examples/Cqs/data'&#125;, &#123;'batch_size': 200&#125;, &#123;'target_size': 100&#125;]I0322 13:53:32.455627 36217 net.cpp:51] Initializing net from parameters: Parameter batch_size:200state &#123;source_dir:/home/amax/cqs/caffe-master/examples/Cqs/data phase: TESTtarget_size:100 level: 0&#125;layer &#123; name: "mylayer" type: "Python" top: "images" python_param &#123;module: "MyPythonLayer"layer: "myPythonLayer"param_str: " \'source_dir\': /home/amax/cqs/caffe-master/examples/Cqs/data, \'batch_size\': 200, \'target_size\': 100 " &#125;&#125;I0322 13:53:32.455687 36217 layer_factory.hpp:77] Creating layer mylayerI0322 13:53:32.456166 36217 net.cpp:84] Creating Layer mylayerI0322 13:53:32.456177 36217 net.cpp:380] mylayer -&gt; imagesI0322 13:53:32.457883 36217 net.cpp:122] Setting up mylayerI0322 13:53:32.457898 36217 net.cpp:129] Top shape: 200 100 100 3 (6000000)I0322 13:53:32.457903 36217 net.cpp:137] Memory required for data: 24000000I0322 13:53:32.457908 36217 net.cpp:200] mylayer does not need backward computation.I0322 13:53:32.457912 36217 net.cpp:242] This network produces output imagesI0322 13:53:32.457917 36217 net.cpp:255] Network initialization done.INFO:root:load /home/amax/cqs/caffe-master/examples/Cqs/data/000001.jpg imagesINFO:root:load /home/amax/cqs/caffe-master/examples/Cqs/data/000002.jpg imagesINFO:root:load /home/amax/cqs/caffe-master/examples/Cqs/data/000003.jpg images.................................196个输出.............................................INFO:root:load /home/amax/cqs/caffe-master/examples/Cqs/data/000015.jpg images(200, 100, 100, 3)Process finished with exit code 0 Reference 参考一 参考二 参考三 参考四]]></content>
      <tags>
        <tag>python, caffe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test]]></title>
    <url>%2F2017%2F03%2F21%2Ftest%2F</url>
    <content type="text"><![CDATA[就为了做个测试。]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F03%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new "My New Post" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy 显示图片hexo中添加图片的方法1.设置站点配置_config.yml post_asset_folder: true 2.安装插件 npm install https://github.com/CodeFalling/hexo-asset-image -- save11 3 引用图片3.1 利用标签引用 1 &#123;% asset_path slug %&#125;2 &#123;% asset_img slug [title] %&#125;3 &#123;% asset_link slug [title] %&#125;123123 3.2 利用makdown ![例子](例子.png)11 More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python-Random]]></title>
    <url>%2F2017%2F03%2F21%2Fpython-random%2F</url>
    <content type="text"><![CDATA[最近在使用python的随机数，所以总结一下。 导入包​ import random 具体的函数 random.random() 随机生成一个0-1之间浮点数 random.uniform(a, b) 生成[a, b]之间的均匀分布的随机数 random.randint(a, b) 生成[a, b]之间的随机的整数 random.randrange(start, stop, step) 生成[start : step : stop]这个数列中的随机一个数。 特例：若step为偶数，start为偶数，则随机生成指定范围的偶数；若start为奇数，则生成指定范围内的奇数 random.choice(sequence) 从序列sequence中随机选择一个元素 random.shuffle(X) 打乱列表X的元素顺序 random.sample(X, k) 从列表X中随机选取K个数]]></content>
      <tags>
        <tag>python,  random</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python创建exe文件]]></title>
    <url>%2F2017%2F03%2F21%2Fpython-to-exe%2F</url>
    <content type="text"><![CDATA[写在前面的话这两天用Python写了一个图片打标签的工具，然后将它包装成了exe文件。在这里记录一下，生成exe的方法。 简介py2exe是一个将Python脚本转化成windows上的可独立执行的程序(*.exe)的工具。这样我们就可以不用装Python而在windows上运行这个可执行程序。 py2exe已经被用于创建wxPython,Tkinter,Pmw,PyGTK,pygame,win32com client server。和其他的独立程序。py2exe是发布在开源许可证下的。 安装py2exe从网站可以下载到py2exe‑0.6.10a1‑cp27‑none‑win_amd64.whl。然后可以使用pip install 安装。 py2exe的使用假设我们有一个脚本：image_labeling.py的python脚本。现在打算将他们转化为exe文件。首先创建一个mysetup.py的脚本。如下： # mysetup.pyfrom distutils.core import setupimport py2exesetup(console=["image_labeling.py"]) 运行方法： python mysetup.py py2exe 上面的命令执行后将产生一个名为dist的子目录，其中包含了myscript.exe, python24.dll, library.zip这些文件。如果你的myscript.py脚本中用了已编译的C扩展模块，那么这些模块也会被拷贝在个子目录中，同样，所有的dll文件在运行时都是需要的，除了系统的dll文件。dist子目录中的文件包含了你的程序所必须的东西，你应将这个子目录中的所有内容一起发布。 默认情况下，py2exe在目录dist下创建以下这些必须的文件：1、一个或多个exe文件。2、python##.dll。3、几个.pyd文件，它们是已编译的扩展名，它们是exe文件所需要的；加上其它的.dll文件，这些.dll是.pyd所需要的。4、一个library.zip文件，它包含了已编译的纯的python模块如.pyc或.pyo上面的mysetup.py创建了一个控制台的myscript.exe程序，如果你要创建一个图形用户界的程序，那么你只需要将mysetup.py中的console=[“myscript.py”]替换为windows=[“myscript.py”]既可。 py2exe一次能够创建多个exe文件，你需要将这些脚本文件的列表传递给console或windows的关键字参数。如果你有几个相关联的脚本，那么这是很有用的。运行下面个命令，将显示py2exe命令的所有命令行标记。python mysetup.py py2exe --help 指定额外的文件一些应用程序在运行时需要额外的文件，诸如配置文件、字体、位图。如果在安装脚本中用data_files可选项指定了那些额外的文件，那么py2exe能将这些文件拷贝到dist子目录中。data_files应包含一个元组(target-dir, files)列表，其中的files是这些额外的文件的列表。示例如下： # mysetup.pyfrom distutils.core import setupimport globimport py2exesetup(console=["myscript.py"], data_files=[("bitmaps", ["bm/large.gif", "bm/small.gif"]), ("fonts", glob.glob("fonts\\*.fnt"))], 说明：data_files选项将创建一个子目录dist\bitmaps，其中包含两个.gif文件；一个子目录dist\fonts，其中包含了所有的.fnt文件。 Windows NT services你可以通过传递一个service关键字参数给setup函数来建造Windows NT services,这个service参数的值必须是一个Python模块名(包含一service类)的列表。示例如下： mysetup.py from distutils.core import setupimport py2exe setup(service=[&quot;MyService&quot;])所建造的可执行的service是可以通过在其后跟一定的命令行参数标记来自行安装和卸载的。你可以通过在这个可执行的service(exe)后跟一-help参数来得到更多的帮助。 COM servers你可以通过传递一个com_server 关键字参数给setup函数来建造Windows NT services,这个service参数的值必须是一个Python模块名(包含一个或多个COM server 类)的列表。示例如下： mysetup.py from distutils.core import setupimport py2exe setup(com_server=[&quot;win32com.server.interp&quot;])默认情况下，DLL和EXE servers被建造，你不需要它们的话你可以简单的删除它们。 reference参考]]></content>
      <tags>
        <tag>python exe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object_detection_NMS]]></title>
    <url>%2F2017%2F03%2F19%2FObject_detection_NMS%2F</url>
    <content type="text"><![CDATA[#写在前面的话 ​ 虽然一直标榜自己是做目标检测的。但是一直也没来总结一下目标检测的细节。打算写一个系列，来好好研究一下faster-rcnn的代码。今天就来先记录一下非极大抑制(NMS)算法。 Non-maximum suppression（非极大抑制） import numpy as npdef nms(dets, thresh): x1 = dets[:, 0] y1 = dets[:, 1] x2 = dets[:, 2] y2 = dets[:, 3] scores = dets[:, 4] areas = (x2 - x1 + 1) * (y2 - y1 + 1) order = scores.argsort()[::-1] # 降序排序，返回索引 keep = [] while order.size &gt; 0: i = order[0] keep.append(i) xx1 = np.maximum(x1[i], x1[order[1:]])#比较x1[i]与x1[order[1:]]中每一个值返回最大值 yy1 = np.maximum(y1[i], y1[order[1:]])#例子： xx2 = np.minimum(x2[i], x2[order[1:]])#np.minimum(2, [1, 3, 6]) 返回:array([2, 3, 6]) yy2 = np.minimum(y2[i], y2[order[1:]]) w = np.maximum(0.0, xx2 - xx1 + 1) h = np.maximum(0.0, yy2 - yy1 + 1) inter = w * h ovr = inter / (areas[i] + areas[order[1:]] - inter) inds = np.where(ovr &lt;= thresh)[0] order = order[inds + 1] return keep 这段代码来自RBG大神。 dets中每一个元素都是一个5维向量，是[X1, Y1, X2, Y2, score], 前四位是坐标，后一位是目标的置信度。 利用scores可以得到boundingbox的优先度，然后保留优先度最大的box,然后寻找与之IOU小于阈值的bbox,然后保留下来，然后再选择余下来的bbox的优先度最大的bbox,再进行比较。直到没有bbox可以比较了为止。 一共有6个识别为人的框，每一个框有一个置信率，现在需要消除多余的框： 按置信率排序：0.95, 0.9, 0.9, 0.8, 0.7, 0.7 取最大0.95的框为一个物体框 剩余5个框中，去掉与0.95框重叠率大于0.6的框，则保留0.9, 0.8, 0.7三个框 重复上面三个步骤， 知道没有框了，0.9为一个框 选出来的为0.95, 0.9 Reference 参考一]]></content>
      <tags>
        <tag>python, object_detection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Genetic_Algorithms]]></title>
    <url>%2F2017%2F03%2F19%2FGenetic-Algorithms%2F</url>
    <content type="text"><![CDATA[写在前面的话因为打算用遗传算法来优化深度神经网络的训练过程，所以，这两天熟悉了一下遗传算法(Genetic algorithms)，这里就来简要的记录一下这两天的学习。 算法遗传算法(genetic algorithm (GA))是计算机数学中用于解决最优化的搜索算法，是进化算法的一种。 遗传算法通常实现方式为一种计算机模拟。对于一个最优化问题，一定数量的候选解(个体)可以抽象表示为染色体，使得种群向更好的解进化。传统上，解用二进制表示(0和1的串)，但是也可以用其他的表示方法。进化从完全随机个体的种群开始，之后一代一代发生。在每一代中评价整个种群的适应度，从当前种群中随机选择多个个体(基于他们的适应度)。通过自然选择和突变产生新的生命种群，该种群在算法的下一次迭代中成为当前种群。 算法流程图 算法细节 编码–&gt;创造染色体 个体–&gt;种群 适应度函数 遗传算子 选择 交叉 变异 运行参数 是否选择精英操作 种群大小 染色体长度 最大迭代次数 交叉概率 变异概率 编码与解码实现遗传算法的第一步就是明确求解问题的解码和编码方式 对于函数优化问题，一般有两种编码方式，各具优缺点 实数编码： 直接用实数表示基因，容易理解且不需要解码过程，但是容易过早收敛，从而陷入局部最优 二进制编码： 稳定性高，种群多样性大，但需要的存储空间大，需要解码且难以理解 个体与种群染色体表达了某种特征，这种特征的载体，称为个体。 适应度函数遗传算法中，一个个体的好坏适应度值来评价。 适应度值越大，解的质量越高。 适应度函数是遗传算法进化的驱动力，也是进行自然选择的唯一标准，他的设计应结合求解问题本身的要求而定。 遗传算子我们希望有这样一个种群，它所包含的个体所对应的函数的最值，但是这个种群一开始可能不那么优秀，因为个体的染色体串是随机生成的。 如何让种群变得优秀呢？ 不断的进化。 每一次进化都尽可能保留种群中的优秀个体，淘汰掉不理想的个体，并且在优秀个体之间进行染色体交叉，有些个体还可能出现变异。 种群的每一次进化，都会产生一个最优个体。种群所有世代的最优个体，可能就是函数最值对应的定义域中的点。 如果种群无休止地进化，那总能找到最好的解。但实际上，我们的时间有限，通常在得到一个看上去不错的解时，便终止了进化。 对于给定的种群，如何赋予它进化的能力呢？ 首先是选择(selection) 选择操作是从前代种群中选择多对较优个体，一对较优个体称之为一对父母，让父母们将它们的基因传递到下一代，直到下一代个体数量达到种群数量上限 在选择操作前，将种群中个体按照适应度从小到大进行排列 采用轮盘赌选择方法（当然还有很多别的选择方法），各个个体被选中的概率与其适应度函数值大小成正比 轮盘赌选择方法具有随机性，在选择的过程中可能会丢掉较好的个体，所以可以使用精英机制，将前代最优个体直接选择 其次是交叉(crossover) 两个待交叉的不同的染色体(父母)根据交叉概率(cross_rate)按某种方式交换其部分基因 采用单点交叉法，也可以使用其他交叉方法 最后是变异(mutation) 染色体按照变异概率(mutate_rate)进行染色体的变异 采用单点变异法，也可以使用其他变异方法 一般来说，交叉概率(cross_rate)比较大，变异概率(mutate_rate)极低。像求解函数最大值这类问题， 因为遗传算法相信2条优秀的父母染色体交叉更有可能产生优秀的后代，而变异的话产生优秀后代的可能性极低，不过也有存在可能一下就变异出非常优秀的后代。这也是符合自然界生物进化的特征的。 待求解问题求解函数 f(x) = x + 10*sin(5*x) + 7*cos(4*x) 在区间[0,9]的最大值。 编码和解码假如设定求解的精度为小数点后4位，可以将x的解空间划分为 (9-0)×(1e+4)=90000个等分。 2^16&lt;90000&lt;2^17，需要17位二进制数来表示这些解。换句话说，一个解的编码就是一个17位的二进制串。 一开始，这些二进制串是随机生成的。 一个这样的二进制串代表一条染色体串，这里染色体串的长度为17。 对于任何一条这样的染色体chromosome，如何将它复原(解码)到[0,9]这个区间中的数值呢？ 对于本问题，我们可以采用以下公式来解码： x = 0 + decimal(chromosome)×(9-0)/(2^17-1) decimal( ): 将二进制数转化为十进制数 一般化解码公式： f(x), x∈[lower_bound, upper_bound]x = lower_bound + decimal(chromosome)×(upper_bound-lower_bound)/(2^chromosome_size-1) lower_bound: 函数定义域的下限upper_bound: 函数定义域的上限chromosome_size: 染色体的长度 通过上述公式，我们就可以成功地将二进制染色体串解码成[0,9]区间中的十进制实数解。 个体与种群本次实验所要解决的一元函数最大值求解问题，个体可以用上一节构造的染色体表示，一个个体里有一条染色体。 许多这样的个体组成了一个种群，其含义是一个一维点集(x轴上[0,9]的线段)。 适应度函数在本问题中，f(x)就是适应度函数。 代码#-*- coding=utf-8 -*-import mathimport randomimport operatorimport time##求解函数 f(x) = x + 10*sin(5*x) + 7*cos(4*x) 在区间[0,9]的最大值。class GA(): def __init__(self, length, count): # 染色体的长度 self.length = length # 种群中染色体的数量 self.count = count # 随机生成及初始种群 self.population = self.gen_population(length, count) def evolve(self, retain_rate=0.2, random_select_rate=0.5, mutation_rate=0.01): """ 进化 对当前一代种群依次进行选择，交叉并生成新一代种群，然后对新一代的种群进行变异 :param retain_rate:当前一代保留的概率 :param random_select_rate:随机选择适应度虽然小但是幸存下来的概率 :param mutation_rate: 变异的概率 """ parents = self.selection(retain_rate, random_select_rate) self.crossover(parents) self.mutation(mutation_rate) def selection(self, retain_rate, random_select_rate): """ 选择 先对适应度从小到大排序，选出存活的染色体 再进行随机选择，选出适应度虽然小，但是幸存下来的个体 :param retain_rate: 当前一代保留的概率 :param random_select_rate: 随机选择适应度虽然小但是幸存下来的概率 :return: 返回留下来交配的染色体 """ #对适应度从小到大排序，选出存活的染色体 grated = [(self.fitness(chromosome),chromosome) for chromosome in self.population] grated = [x[1] for x in sorted(grated, reverse=True)] #选出适应性强的染色体 retain_length = int(len(grated) * retain_rate) parents = grated[:retain_length] # 选择前retain_length个元素 #选出适应性不强，但是幸存下来的染色体 for chromosome in grated[retain_length:]: if random.random() &lt; random_select_rate: parents.append(chromosome) return parents def crossover(self, parents): """ 染色体的交叉，繁殖，生成新一代的种群 :param parents: 父母 :return: 新一代种群 """ #新出生的孩子，最终会被加入存活下来的父母之中，形成新一代的种群。 children =[] #需要繁殖的孩子的量 target_count = len(self.population) - len(parents) #开始根据需要的量进行繁殖 while len(children) &lt; target_count: male = random.randint(0, len(parents)-1) female = random.randint(0,len(parents)-1) if male != female: #随机选择交叉点 cross_pos = random.randint(0, self.length) #生成掩码，方便位操作 mask = 0 for i in xrange(cross_pos): mask |= (1 &lt;&lt; i) male = parents[male] female = parents[female] #孩子将获得父亲在交叉点前的基因和母亲在交叉点后的(包括交叉点)的基因 child = ((male &amp; mask) | (female &amp; ~mask)) &amp; ((1 &lt;&lt; self.length) -1) children.append(child) #经过繁殖后，孩子和父母的数量与原始种群的数量相等，在这里可以更新种群 self.population = parents + children def mutation(self, rate): """ 变异 对种群中的所有个体，随机改变某个个体中的某个基因 :param rate: :return: """ for i in xrange(len(self.population)): if random.random() &lt; rate: j = random.randint(0, self.length -1) self.population[i] ^= 1 &lt;&lt; j def gen_chromosome(self, length): """ 随机生成长度为length的染色体， 每个基因的取值为0或者1 这里用一个bit表示一个基因 :param length: 染色体的长度 :return: 一个长度为length的染色体，每一位为0或者1 """ chromosome = 0 for i in xrange(length): # 1 &lt;&lt; i ==&gt; 2 ^ i chromosome |= (1 &lt;&lt; i) * random.randint(0, 1) #x |= 5 ==&gt; x = x | 5 return chromosome def gen_population(self, length, count): """ 获取初始种群(一个含有count个长度为length的染色体列表) :param length: 染色体的长度 :param count: 种群的染色体数量 :return: 一个含有count个长度为length的染色体列表 """ return [self.gen_chromosome(length) for i in xrange(count)] def fitness(self, chromosome): """ 计算适应度， 将染色体解码为0~9之间的数字，带入函数计算 以为求解最大值，所以数值越大，适应度越高 :param chromosome: 染色体 :return: 返回适应度 """ x = self.decode(chromosome) return x + 10*math.sin(5*x) + 7*math.cos(4*x) def decode(self, chromosome): """ 解码染色体，将二进制转化为属于[0,9]之间的额实数 :param chromosome: 二进制表达的染色体 :return: [0,9]之间的数字 """ return chromosome * 9.0 / (2**self.length -1) def result(self): """ 获取当前代的最优值，智力取得是函数取最大值的x的值 :return: """ grated = [(self.fitness(chromosome), chromosome) for chromosome in self.population] grated = [x[1] for x in sorted(grated, reverse=True)] return ga.decode(grated[0])if __name__=='__main__': #染色体长度为17，种群数量为300 ga = GA(17, 300) time1 = time.time() #200次进化diedai for x in xrange(200): ga.evolve() time2 = time.time() print "结果是： ", ga.result() print "运行时间是：", time2 - time1 结果结果是： 7.85748182283运行时间是： 0.155000209808 写在后面的话现实问题转化到遗传算法是一个难点，也就是如何有效地将现实问题映射到遗传算法个个体上，完成了这一步，后面的三个算子也就是按部就班的事情了。 遗传算法中有很多参数，比如说，初始种群的数量，交叉概率，变异概率，进化代数等等，这些参数影响算法的收敛速度和收敛值。 遗传算法是一种仿生算法，类似的算法还有模拟退火算法、粒子群算法、蚁群算法、禁忌搜索，统称为元启发式算法（Meta-heuristic algorithms）这类算法得益于自然界现象的启发，而不是像确定性算法那样的数字论证。 reference：参考一 参考二]]></content>
      <tags>
        <tag>python, Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python_PIL_matplotlib]]></title>
    <url>%2F2017%2F03%2F17%2Fpython-PIL-matplotlib%2F</url>
    <content type="text"><![CDATA[PILPIL的全称为Python Imaging Library, 是Python中的一个免费的图像处理模块。 导入包from PIL import Image 图片读取from PIL import Imageimg = Image.open('000001.jpg') # 返回一个Image图像对象print img#结果&lt;PIL.JpegImagePlugin.JpegImageFile image mode=RGB size=353x500 at 0x2945A90&gt; 图像显示导入包import matplotlib.pyplot as plt 代码段： import matplotlib.pyplot as pltfig, ax = plt.subplots(figsize=(5, 5)) #定义一个12*12 大小的画板ax.imshow(img) #显示图片，此时图片还在内存中plt.axis('off') #消除横纵坐标ax.set_title('000001.jpg')#设置一个标题plt.show()#显示图片，要不然没有办法显示 图片显示结果 图片保存img = Image.open('000001.jpg') # 返回一个Image图像对象img_save = img.save('000001_save.png')#保存图片并且同时改变图片的格式 图片转化为灰度图img_save = img.save('000001_save.png')img_gray = img.convert("L")print img_gray#结果&lt;PIL.Image.Image image mode=L size=353x500 at 0x264F780&gt; 灰度图片显示 Image对象和图像矩阵之间转换导入包import numpy as np Image对象转化成图像矩阵Image对象转化成图像矩阵只要将Image对象作为numpy.array()参数即可 from PIL import Imageimport numpy as npimg_array = np.array(img)print img_array#结果[[[ 1 1 0] [ 1 1 0] [ 1 1 0] #忽略 [ 31 60 116] [ 32 58 119] [ 26 50 120]]] 图像矩阵转化为Image对象图像矩阵转化成Image对象通过Image模块的fromarray()方法。 from PIL import Imageimport matplotlib.pyplot as pltimport numpy as npimg = Image.open('000001.jpg') # 返回一个Image图像对象img_array = np.array(img)img_array = 255 - img_arrayimg_neg = Image.fromarray(img_array) 创建缩略图创建图像缩略图可以通过Image的thumbnail()方法，参数传入一个元组，指明缩略图的大小，如thumbnail((128,128)) 图片截取截取图像中的一部分，并将这一部分作为一个新的Image对象。截取区域的方法为crop()，参数为一个含4个元素的元组，用来指定截取区域的左上角点和右下角点。 from PIL import Imageimport matplotlib.pyplot as pltimport numpy as npimg = Image.open('000001.jpg') # 返回一个Image图像对象box = (48,240,196,372)img_crop = img.crop(box) 图像的尺寸调整和旋转尺寸调整方法为resize()，参数为一元组，指定调整后的大小，如resize((128,128))。 图像旋转的方法为rotate()，参数为旋转角度（数值，单位为度）,逆时针方向，如rotate(45)` from PIL import Imageimport matplotlib.pyplot as pltimg = Image.open('000001.jpg') # 返回一个Image图像对象image_resize = img.resize((200,200))image_rotate = img.rotate(45)fig, (ax1, ax2) = plt.subplots(1,2,figsize=(8, 8)) #定义一个12*12 大小的画板#显示第一幅图片ax1.imshow(image_resize)ax1.axis('off') #消除横纵坐标ax1.set_title('image_resize')#设置一个标题#显示第二幅图片ax2.imshow(image_rotate)ax2.axis('off') #消除横纵坐标ax2.set_title('image_resize')#设置一个标题plt.show()#显示图片，要不然没有办法显示 图像直方图图像直方图用来统计图像中像素值的分布情况，即统计不同像素值出现的次数。方法为调用matplotlib.pyplot的hist方法，参数传入图像像素序列和统计区间个数。 from PIL import Imageimport matplotlib.pyplot as pltimport matplotlib.cm as cmimport numpy as np# 读入图片并转化为灰度图img = Image.open('000001.jpg').convert("L")image_array = np.array(img)#画图plt.subplot(1, 2, 1)plt.imshow(img,cmap=cm.gray)plt.axis("off")plt.subplot(1, 2, 2)plt.hist(image_array.flatten(), 256) #flatten 可以将矩阵转化为一维序列plt.show()#显示图片，要不然没有办法显示 图像灰度变换对于一张灰度图像，其每个像素点都用一个0-255之间的值表示，0表示黑色，越接近0越黑；255表示白色，越接近255越白。灰度变换就是通过一个特定的函数，使灰度值从一个值转换成另外一个值。这里列出3种灰度变换 【反相】变换后的灰度值= 255−原灰度值 【转换到100-200】变换后的灰度值 =(原灰度值/255)*100+100 【像素平方】变换后的灰度值 = 255*(原灰度值/255)2 from PIL import Imageimport matplotlib.pyplot as pltimport matplotlib.cm as cmimport numpy as np# 读入图片并转化为灰度图img = Image.open('000001.jpg').convert("L")image_array = np.array(img)x = np.arange(255)#画图# 反相plt.subplot(3,2,1)plt.plot(x,255-x) # 画出变换函数图像plt.subplot(3,2,2)plt.imshow(Image.fromarray(255-image_array),cmap=cm.gray)plt.axis("off")# 转换到 100-200plt.subplot(3,2,3)plt.plot(x,(x/255.0)*100+100) # 画出变换函数图像plt.subplot(3,2,4)plt.imshow( Image.fromarray((image_array/255.0)*100+100), cmap=cm.gray )plt.axis("off")# 像素平方plt.subplot(3,2,5)plt.plot(x,255*(x/255.0)**2) # 画出变换函数图像plt.subplot(3,2,6)plt.imshow( Image.fromarray(255*(image_array/255.0)**2), cmap=cm.gray )plt.axis("off")plt.show() 直方图均衡化由上面图像的直方图可以看出，一般情况下，图像上某些灰度值较多，有些灰度值较少，直方图均衡化为的是使灰度值较为均衡。 直方图均衡化是利用直方图的累积函数作为灰度变换函数，对图像进行转换。直方图均衡化可以增强图像的对比度。 累积函数和概率论中的累积分布函数类似。例如对于还有5个数的序列[1,2,3,4,5],其累积函数含有5个数，第一个数是1，第二个是1+2=3，……，第五个数是1+2+3+4+5=15，所以其累积函数是[1,3,6,10,15]。 我们把直方图均衡化的过程封装在一个函数里面，函数名字叫做histeq，输入原图像矩阵和直方图分块数，输出均衡化后的图像矩阵和累积函数。 from PIL import Imageimport matplotlib.pyplot as pltimport matplotlib.cm as cmimport numpy as npdef histeq(image_array, image_bins=256): # 将图像矩阵转化成直方图数据，返回元组(频数，直方图区间坐标) image_array2, bins = np.histogram(image_array.flatten(), image_bins) # 计算直方图的累积函数 cdf = image_array2.cumsum() # 将累积函数转化到区间[0,255] cdf = (255.0 / cdf[-1]) * cdf # 原图像矩阵利用累积函数进行转化，插值过程 image2_array = np.interp(image_array.flatten(), bins[:-1], cdf) # 返回均衡化后的图像矩阵和累积函数 return image2_array.reshape(image_array.shape), cdf# 读入图片并转化为灰度图img = Image.open('000001.jpg').convert("L")image_array = np.array(img)plt.subplot(2,2,1)plt.hist(image_array.flatten(),256)plt.subplot(2,2,2)plt.imshow(img,cmap=cm.gray)plt.axis("off")a = histeq(image_array) # 利用刚定义的直方图均衡化函数对图像进行均衡化处理plt.subplot(2,2,3)plt.hist(a[0].flatten(),256)plt.subplot(2,2,4)plt.imshow(Image.fromarray(a[0]),cmap=cm.gray)plt.axis("off")plt.show()]]></content>
      <tags>
        <tag>python, PIL, matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python_parse_VOCxml_and_show]]></title>
    <url>%2F2017%2F03%2F15%2Fpython-parse-VOCxml-and-show%2F</url>
    <content type="text"><![CDATA[前言今天详细的处理了 一下VOC的XML 文件，包括将xml 解析出来，并将bbox显示出来。 简要介绍一下VOC的xml文件VOC的检测任务的目标标签是写在对应xml文件中的。一般xml文件会包含对应图片的名字，尺寸，以及难度，以及所有目标的名字，和boundingbox的对角坐标。 下面给出一个xml的示例： &lt;annotation&gt; &lt;folder&gt;VOC2007&lt;/folder&gt; &lt;filename&gt;000001.jpg&lt;/filename&gt; &lt;source&gt; &lt;database&gt;The VOC2007 Database&lt;/database&gt; &lt;annotation&gt;PASCAL VOC2007&lt;/annotation&gt; &lt;image&gt;flickr&lt;/image&gt; &lt;flickrid&gt;341012865&lt;/flickrid&gt; &lt;/source&gt; &lt;owner&gt; &lt;flickrid&gt;Fried Camels&lt;/flickrid&gt; &lt;name&gt;Jinky the Fruit Bat&lt;/name&gt; &lt;/owner&gt; &lt;size&gt; &lt;width&gt;353&lt;/width&gt; &lt;height&gt;500&lt;/height&gt; &lt;depth&gt;3&lt;/depth&gt; &lt;/size&gt; &lt;segmented&gt;0&lt;/segmented&gt; &lt;object&gt; &lt;name&gt;dog&lt;/name&gt; &lt;pose&gt;Left&lt;/pose&gt; &lt;truncated&gt;1&lt;/truncated&gt; &lt;difficult&gt;0&lt;/difficult&gt; &lt;bndbox&gt; &lt;xmin&gt;48&lt;/xmin&gt; &lt;ymin&gt;240&lt;/ymin&gt; &lt;xmax&gt;195&lt;/xmax&gt; &lt;ymax&gt;371&lt;/ymax&gt; &lt;/bndbox&gt; &lt;/object&gt; &lt;object&gt; &lt;name&gt;person&lt;/name&gt; &lt;pose&gt;Left&lt;/pose&gt; &lt;truncated&gt;1&lt;/truncated&gt; &lt;difficult&gt;0&lt;/difficult&gt; &lt;bndbox&gt; &lt;xmin&gt;8&lt;/xmin&gt; &lt;ymin&gt;12&lt;/ymin&gt; &lt;xmax&gt;352&lt;/xmax&gt; &lt;ymax&gt;498&lt;/ymax&gt; &lt;/bndbox&gt; &lt;/object&gt;&lt;/annotation&gt; 对应的图片是： python解析XML文件导入xml包import xml.etree.ElementTree as ET 直接贴代码 def parse_rec(filename): """parse a pascal voc xml file""" tree = ET.parse(filename) # objects = [] for obj in tree.findall('object'): obj_struct = &#123;&#125; obj_struct['name'] = obj.find('name').text obj_struct['pose'] = obj.find('pose').text obj_struct['truncated'] = int(obj.find('truncated').text) obj_struct['difficult'] = int(obj.find('difficult').text) bbox = obj.find('bndbox') obj_struct['bbox'] = [int(bbox.find('xmin').text), int(bbox.find('ymin').text), int(bbox.find('xmax').text), int(bbox.find('ymax').text)] objects.append(obj_struct) return objects 如此得到的结果是一个list, list中的元素就是每一个object, 可以看到object每一个都是一个dict(键值对)： [{&#39;difficult&#39;: 0, &#39;pose&#39;: &#39;Left&#39;, &#39;name&#39;: &#39;dog&#39;, &#39;bbox&#39;: [48, 240, 195, 371], &#39;truncated&#39;: 1}, {&#39;difficult&#39;: 0, &#39;pose&#39;: &#39;Left&#39;, &#39;name&#39;: &#39;person&#39;, &#39;bbox&#39;: [8, 12, 352, 498], &#39;truncated&#39;: 1}] python显示xml结果导入matplotlib和PIL包from PIL import Imageimport matplotlib.pyplot as plt 直接贴代码 image = Image.open('000001.jpg')fig, ax = plt.subplots(figsize=(12, 12))ax.imshow(image, aspect='equal')for i in range(len(object)): bbox = object[i]['bbox'] name = object[i]['name'] ax.add_patch( plt.Rectangle((bbox[0], bbox[1]), bbox[2] - bbox[0], bbox[3] - bbox[1], fill=False, edgecolor='red', linewidth=3.5 ) )#画矩形 ax.text(bbox[0], bbox[1] - 2, '&#123;:s&#125;'.format(name), bbox=dict(facecolor='blue', alpha=0.5), fontsize=14, color='white')#矩形框的标签ax.set_title('parse image ')plt.axis("off")plt.tight_layout()plt.show() 结果图： 后语]]></content>
      <tags>
        <tag>python VOCxml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Written Memories:Understanding,Deriving and Extending the LSTM]]></title>
    <url>%2F2016%2F08%2F25%2FWritten-LSTM%2F</url>
    <content type="text"><![CDATA[写在前面的话动机：锻炼一下自己的英文能力，同时加深对LSTM的理解。 本文是对Written Memories: Understanding, Deriving and Extending the LSTM的翻译。 有什么错误请指正！ 当我第一次接触 Long Short-Term Memory networks(LSTM)时，我很难理解它的复杂性。我甚至不理解为什么它以这种方式设计就可以产生很好地 效果。后来，我发现LSTM是可以被理解的。尽管它表面看起来很复杂。LSTM实际上是基于一系列十分简单，甚至优美的对于神经网络的一些深刻思考。我真希望这篇博客是我第一次学习循环神经网络。 在这篇博文中，我们将做如下几件事情： 我们将定义recurrent neural networks(RNNs)，我们将关注于RNNs的局限性，从而导致了LSTM的发展。 我们将介绍LSTM结构背后的直觉。然后我们以此为依据拓展LSTM。沿着这个思路，我们将派生出GRU。我们将推导出伪LSTM。而这种LSTM将比传统的LSTM的性能更好。 接下来我们将推广这些直觉的知识是怎么在最近的优秀的结构中得到运用的。比如（highway，残差网络，神经图灵机）。 本文是关于理论知识的，并没有实现的内容，至于使用Tensorflow实现RNNs可以参考如下的博客。 Recurrent Neural Networks in Tensorflow I和Recurrent Neural Networks in Tensorflow II。 内容/快速链接： 递归神经网络 RNNs可以做什么？选择单位时间 主流的RNNs 信息变形，弥散，和爆炸敏感性 针对信息弥散的充要条件 沿着时间轴的后向传播和梯度弥散敏感度 解决梯度弥散和梯度爆炸问题 LSTMs背后的直觉知识：保存记忆 使用选择性的控制和协调 选择的机制：Gates 将Gates粘合在一起派生出了LSTM原型 三个模型：归一化原型，GRU, 以及伪LSTM 推导LSTM 有窥视孔的LSTM 基本的LSTM与伪LSTM的经验性比较 拓展LSTM 要求： ​ 本篇文章假设读者已将熟悉了： 前向神经网络 反向传播 基本的线性代数 我们也将回顾一些其他的知识，让我们从RNNs开始吧。 循环神经网络​ ​ 从一个时刻到下一个时刻，我们的大脑就像一个函数一样在工作，它从我们的感官（外部）和我们的思维（内部）得到输入，然后处理一番，得到以动作形式（外部）和新的想法（内部）的输出。例如，我们看到 一只熊，然后我们就会想到单词“熊”，我们可以构建一个神经网络来模拟这种行为，我们可以训练神经网络去联想到单词“熊”当它看到一张熊的照片的时候。但是我们的大脑不仅仅是一个只有一次的函数，它随着时间重复运行。我们看见一只熊，然后我们想到了单词“熊”,然后我们就会想到“跑”， 重要的是，将熊的图片转化为单词“熊的网络和将单词“熊”转化为”跑“的网络是十分相似的。同时，它也是一个 循环的函数，对于这样的函数我们可以用递归神经网络来模拟。 ​ RNN网络是一系列完全相同的前向神经网络的组合，每一个前向神经网络处理每一个时间步，我们都称之为“RNN cells”.值得注意的是这个定义比我们通常的对RNN的定义(“vanilla” RNN将在下文中介绍作为LSTM的先驱)更为广泛。这些cells可以处理他们自己的输出，允许他们(cells)被组合。他们同时可以处理外部的输入，产生外部的输出。下面是单独一个RNN cell 的示例图： 下面是三个RNN cell的组合的示例图： ​ 你可以认为这种循环的输出是“状态”，他们被输入到下一个时间步。所以，一个“RNN cell” 接收前一个状态和现有的输入(可选)，然后输出现在的状态，以及现在的输出(可选)。 下面是“RNN cell” 的代数描述:$$\binom{s{t}}{o{t}} = f\binom{s{t-1}}{x{t}}$$其中：$$s{t}和s{t-1}表示当前和前一刻状态$$ $$o_{t}表示当前时刻的输出(可能是空)$$ $$x_{t}是当前状态的输入,f是当前的循环函数$$ ​ 我们就大脑的运行方式：当前的神经元活动将会替代之前的神经元活动。我们可以将RNNs看做这种原地的操作，因为”RNN cell”是完全相同的，他们可以被看做是相同的对象，只是在每一个时间步他们的状态会被覆盖。下面是这个框架的示例图： ​ 大多数对于RNNs的介绍都是从”single cell loop”框架开始的，但是我认为读者应该会认为以上连续的框架会更加的直观，特别是考虑到反向传播的时候。当我们从”single cell loop”开始学习的额时候。RNN会被引入”unrolled”以得到上面所提到的连续的框架。 RNNs可以做什么？选择单位时间​]]></content>
      <tags>
        <tag>LSTM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CUDA安装教程]]></title>
    <url>%2F2016%2F08%2F22%2FCUDA_installration%2F</url>
    <content type="text"><![CDATA[动机：重新整理一下CUDA的安装过程(虽然已经安装过很多次了)。 环境： Ubuntu14.04， Titanx 显卡. 待安装： CUDA7.5， cuDNN v5.1(下载这个，你得先注册了。注册然后等一天，才有资格下载。). 简介: CUDA(Compute Unified Device Architecture)，是显卡厂商NVIDIA推出的运算平台。 CUDA™是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。 它包含了CUDA指令集架构（ISA）以及GPU内部的并行计算引擎。 开发人员现在可以使用C语言来为CUDA™架构编写程序，C语言是应用最广泛的一种高级编程语言。所编写出的程序于是就可以在支持CUDA™的处理器上以超高性能运行。CUDA3.0已经开始支持C++和FORTRAN。 Step1：下载所需的文件 *首先从网站上下载CUDA 和 cuDNN v5.1。至于CUDA选择哪个版本的可以参考下图 Step2： 安装CUDA sudo dpkg -i cuda-repo-ubuntu1404-7-5-local_7.5-18_amd64.debsudo apt-get updatesudo apt-get install cuda Step3： 安装cuDNN tar -zxvf cudnn-7.5-linux-x64-v5.1.tgz cd cudnn-7.5-linux-x64-v5.1 sudo cp lib* /usr/local/cuda/lib64/ ## 这一步是在 lib文件夹下面 sudo cp cudnn.h /usr/local/cuda/include/ 更新软连接 cd /usr/local/cuda/lib64/ sudo rm -rf libcudnn.so libcudnn.so.5 sudo ln -s libcudnn.so.5.0.5 libcudnn.so.5.0 sudo ln -s libcudnn.so.5.0 libcudnn.so Step4：设置环境变量 在/etc/profile中添加CUDA环境变量 sudo gedit /etc/profile 内容如下: PATH=/usr/local/cuda-7.5/bin:$PATHexport PATH 保存后, 执行下列命令, 使环境变量立即生效 source /etc/profile 同时需要添加lib库路径： 在 /etc/ld.so.conf.d/加入文件 cuda.conf, sudo gedit /etc/ld.so.conf.d/cuda.conf 内容如下: /usr/local/cuda-7.5/lib64 保存后，执行下列命令使之立刻生效 sudo ldconfig DONE !检验一下安装情况吧： nvidia-smi]]></content>
      <tags>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2D_Convolution]]></title>
    <url>%2F2016%2F08%2F18%2F2D-Convolution%2F</url>
    <content type="text"><![CDATA[本文原地址:this page 卷积运算(Convolution)是通过两个函数f 和g 生成第三个函数的一种数学算子，表示函数f 与经过翻转和平移与g 的重叠部分的累积。如果将参加卷积的一个函数看作区间的指示函数，卷积还可以被看作是“滑动平均”的推广。 假设: f(x),g(x)是R1上的两个可积函数，并且积分是存在的。这样，随着 x 的不同取值，这个积分就定义了一个新函数h(x)，称为函数f 与g 的卷积，记为h(x)＝(f*g)(x)。 两个向量卷积，说白了就是多项式乘法。下面用个矩阵例子说明其工作原理： a和d的卷积就是，把a和d的第一行作为一个多项式的系数，按多项式升幂排列（也可以按降幂），即为： 所得卷积矩阵为： 这就是卷积运算的工作原理，在图像处理中用处非常大。]]></content>
      <tags>
        <tag>卷积</tag>
      </tags>
  </entry>
</search>
